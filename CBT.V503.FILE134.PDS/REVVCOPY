         TITLE '  R E V S U B S 2  '
**********************************************************************
*
*        Control sections in this source file:
*
*         REVISPF - Invoke ISPF EDIT, BROWSE or VIEW functions.
*         REVHIST - Invoke Binder to show program history and map.
*         REVUNIX - Format, display and navigate UNIX directories,
*                   and set up for UNIX data REVIEW.
*         REVPDSE - Format, display and navigate PDSE program library
*                   directory.
*
**********************************************************************
         EJECT
**********************************************************************
*
*  R40.0  31MAR06 - Create REVSUBS2 source member to contain
*                   the post-370 CSECTs from REVSUBS.
*  R41.6  17APR08 - Enhance program object PDSE member sorting
*                   including cursor-triggered sorting.
*                 - Report program object sublevel as a superscript as
*                   part of the member's Program Management version.
*  R41.9  16AUG08 - Fix REVHIST DIV GETMAIN call for PDSEs.
*  R42.1  31DEC08 - Fix S0C4 after 'H' selection of PDSE program.
*  R43.0  19APR09 - Normalize REVIEW2 save area chaining.
*         11OCT09 - Allow quoted initial UNIX directory.
*         01DEC09 - Allow binary UNIX even if not 80-byte "records".
*  R43.5  12AUG10 - Rewrite REVHIST - use dialog API for PDSE/PDS/HFS.
*  R43.8  18AUG11 - Fix UNIX ASCII Line Feed processing.
*                 - Sort UNIX entries after read in even if by name.
*                 - Add "cursor next to processed entry" support, with
*                   "always show all entries if enough visible lines".
*                 - Upper case PDSE LOC operand if all names are.
*  R44.0  27JAN14 - Fix browse of z/OS UNIX ZIP files.
*  R46.5  16APR16 - Move REVISPF here from REVSUBS.
*                 - Use FIND operand as search argument.
*
**********************************************************************
         TITLE '  R E V I S P F   -   C A L L   I S P F  '
**********************************************************************
*                                                          *         *
*         ISPF EDIT, BROWSE AND VIEW INTERFACE             * AW@IDAPS*
*                                                          *  06/86  *
**********************************************************************

**********************************************************************
*                                                                    *
* Registers on entry: R15-> REVISPF                                  *
*                     R14-> Return address                           *
*                     R13-> Save area                                *
*                     R9 -> @DATA                                    *
         AIF   (NOT &ENVZV2).GENMEM0
*                     R4  = Member's absolute generation number      *
.GENMEM0 ANOP
*                     R1 -> Selection data stream                    *
*                                                                    *
*                                                                    *
* During processing:  R13-> @SPFWORK (local GETMAINed area)          *
*                                                                    *
* Return codes:       R15 = 0      MEMBER SAVED                      *
*                     R15 = 4      MEMBER NOT SAVED                  *
*                     R15 = 14     MEMBER IN USE                     *
*                     R15 = 16     MEMBER NOT FOUND                  *
*                     R15 = 20     SEVERE ERROR - UNABLE TO CONTINUE *
*                     R15 = 30     ISPF NOT ACTIVE                   *
*                     R15 = 40     GETMAIN FAILED                    *
*                     R15 = 50     ISPLINK NOT IN SYSTEM             *
*                                                                    *
* The return code is also saved in the first word of 'DOUBLE'.       *
*                                                                    *
**********************************************************************

REVISPF  CSECT
REVISPF  AMODE 31
         B     @ISPF-*(,R15)
         DC    AL1(7),CL7'REVISPF'
@ISPF    STM   R14,R12,12(R13)
         LR    R11,R15
         USING REVISPF,R11
         LR    R2,R13                  Copy @PDSAREA pointer
         LR    R5,R1                   Copy selection text pointer
         SR    R0,R0
         LA    R0,$SPFWKLN             Load length of DSA
         GETMAIN RC,LV=(0)             Get the storage
         LTR   R15,R15
         BZ    SPFGETOK
         LM    R14,R12,12(R13)         Restoer caller's registers
         LA    R15,40                  Set return code to 40
         BR    R14                     Return to caller
SPFGETOK DS    0H
         LR    R13,R1                  Save the address in R13
         USING @SPFWORK,R13
         ST    R13,8(,R2)              Store forward and
         ST    R2,4(,R13)              Backchain pointers
         AIF   (NOT &ENVZV2).GENMEM1
         ST    R4,MEMABGEN             Save absolute generation
.GENMEM1 ANOP
         LA    R4,50                   Prepare bad return code of 50
         MVC   DOUBLE,ISPLNKNM         Load expected entry point name
         TM    OSBITS,X'13'            Is this OSIV/F4 or MSP?
         BO    ISPFITIS                No, should be some sort of MVS
         MVC   DOUBLE,PFDLNKNM         Yes, ISPLINK is alias of PFDLINK
ISPFITIS DS    0H                           but need entry PFDLINKX
         LOAD  EPLOC=DOUBLE,ERRET=ISPFEXIT  Pre-load reentrant module
         ST    R0,ISPLNKAD             Save address of ISPLINK
         TM    STATUS9,$9ISPF          Already running as ISPF dialog?
         BO    ISPFSCRN                Yes, skip unnecessary call
         LA    R1,ISPCDRPL             Point to ISPLINK plist
         L     R15,ISPLNKAD            Load ISPLINK entry point
         BASR  R14,R15                 Call ISPLINK
         LA    R4,30                   Set retcode to 30
         LTR   R15,R15                 Test return code
         BNZ   ISPFRETN                 and return if bad
ISPFSCRN DS    0H
         TM    $UCBAD,$HFSIO           HFS request?
         BO    ISPFHFS                 Yes, handle it
         MVI   EDATASET,QUOTE          Move in first quote
         LH    R3,$DSNAME              Get data set name length
         LA    R1,$DSNAME-2            Point 4 bytes behind dsn start
         LA    R7,$VOLSER              Point to first/only volume
         TM    DS1SMSFG,DS1SMSDS       SMS-managed?
         BZ    SPFVOLOK                No, supply the volume explicity
         LA    R7,=CL6' '              Yes, allow recall to any disk by
SPFVOLOK SR    R0,R0                        using the catalog entry
         ICM   R0,1,$CONCAT            Load concat'n number
         BZ    GETSPFDS                Zero so use $DSNAME
         L     R1,ARLAREA              Point to first retrieved JFCB
ISPFJFCB BCT   R0,ISPFJFLP             Chain through JFCBs
         B     GOTSPFJF                Now pointing to correct JFCB
ISPFJFLP AH    R1,0(,R1)               Point to next JFCB
         B     ISPFJFCB                Process it
GOTSPFJF LA    R7,122(,R1)             Point to volume in JFCB
         LA    R3,44                   Get maximum dsn length
         LA    R15,47(,R1)             Point to last dsn character
CNCTSPFL CLI   0(R15),C' '             Trailing blank?
         BNE   GETSPFDS                No, now have dsname length
         BCTR  R15,0                   Yes, point to previous character
         BCT   R3,CNCTSPFL             Decrement len and test previous
GETSPFDS LA    R2,EDATASET+1           Point to ISPF dataset name
         EX    R3,MDSN                 Move dataset name
         AR    R2,R3                   Increment dataset pointer
         MVC   0(2,R2),RIGHTBQ+1       Add quote
         CLC   =CL8' ',$MEMBER         Blank member name?
         BE    QUOTESOK                Yes, no member name to add
         MVI   0(R2),C'('              Move left bracket
         LA    R2,1(,R2)               Increment dataset pointer
         MVC   0(8,R2),$MEMBER         Move in the member name
         LA    R6,8
BLNKLOP  DS    0H                      Loop and search for the blank
         LA    R2,1(,R2)               Increment pointer
         CLI   0(R2),C' '              Is it a blank?
         BE    MOVRB                   Yes!
         BCT   R6,BLNKLOP              No branch back
MOVRB    DS    0H
         MVC   0(3,R2),RIGHTBQ         Move right bracket and quote
QUOTESOK CLI   SACHAR,X'0E'            Fujitsu terminal hardware?
         BNE   SPFSCROK                No, colour is not a problem
         LA    R1,ERASECMD             Point to erase/write command
         LA    R0,L'ERASECMD           Load data stream length
         ICM   R1,8,=X'03'             Tput flags (fullscreen)
         TPUT  (1),(0),R               Reset character attributes
SPFSCROK DS    0H
         TM    OSBITS,X'13'            OSIV/F4 E40, MSP E10 or MSP E20?
         BNO   CALLSPFD                Yes, call "SPFD" (SPF or PFD)

*        Under PFD, members should only be selected with a 'B' or 'E'
*        from option "6".  Elsewhere from PFD is alright until you exit
*        completely from REVIEW whereupon a PFD main task abend occurs.
*        A 'CONTROL ERRORS RETURN' wrecks even this capability.
*        (Note that PFD does not support recursive Browse or Edit.)

         LA    R1,ISPCERPL             Point to ISPLINK plist
         L     R15,ISPLNKAD            Load ISPLINK entry point
         BASR  R14,R15                 Call ISPLINK
CALLSPFD LA    R1,EDITCMD
         CLI   0(R5),C'E'              Edit requested?
         BE    EDITITIS                Yes
         AIF   (NOT &ENVZV2).GENMEM2
         TM    STATUS15,$15GEN         Showing member generations?
         BNO   PLAINSPF                No, skip generation stuff
         ICM   R0,15,MEMABGEN          Is member a gneration?
         BZ    PLAINSPF                No, skip generation stuff
         L     R15,ISPLNKAD            Load ISPLINK entry point
         CALL  (15),(LMINIT,REVDATID,CHARBLNK,CHARBLNK,CHARBLNK,       +
               CHARBLNK,CHARBLNK,CHARBLNK,CHARBLNK,$DDNAME),           +
               VL,MF=(E,SPFPLIST)      LMINIT REVDATID $DDNAME
         LA    R4,40(,R15)
         LTR   R15,R15                 Success?
         BNZ   ISPFRETN                No
         L     R15,ISPLNKAD            Load ISPLINK entry point
         CALL  (15),(VCOPY,DATIDLST,DATIDLEN,REVDATID,OPTMOVE),        +
               VL,MF=(E,SPFPLIST)      VDEFINE REVDATID
         LA    R4,50(,R15)
         LTR   R15,R15                 Success?
         BNZ   ISPFRETN                No
         L     R15,ISPLNKAD            Load ISPLINK entry point
         CLI   0(R5),C'V'              View requested?
         BE    GENVIEW                 Yes
         CALL  (15),(BRWSCMD,CHARBLNK,CHARBLNK,CHARBLNK,CHARBLNK,      +
               REVDATID,$MEMBER),                                      +
               VL,MF=(E,SPFPLIST)      BROWSE REVDATID $MEMBER
         B     MGENAFTR
GENVIEW  CALL  (15),(VIEWCMD,CHARBLNK,CHARBLNK,CHARBLNK,CHARBLNK,      +
               REVDATID,$MEMBER),                                      +
               VL,MF=(E,SPFPLIST)      VIEW REVDATID $MEMBER
MGENAFTR LR    R4,R15                  Save return code
         B     MGENDONE
PLAINSPF EQU   *
.GENMEM2 ANOP
         LA    R1,VIEWCMD
         CLI   0(R5),C'V'              View requested?
         BE    EDITITIS                Yes
         LA    R1,BRWSCMD
EDITITIS ST    R1,SPFPLIST
         LA    R1,EDATASET
         ST    R1,SPFPLIST+4
         ST    R7,SPFPLIST+8           Point to volume serial number
         OI    SPFPLIST+8,X'80'        Indicate last parameter
ISPFFILE LA    R1,SPFPLIST             Point to ISPLINK plist
         L     R15,ISPLNKAD            Load ISPLINK entry point
         BASR  R14,R15                 Call ISPLINK
SPFHFSBD LR    R4,R15                  Save ISPLINK return code

MGENDONE TM    STATUS9,$9ISPF          Running as ISPF dialog anyway?
         BO    ISPFRETN                Yes, skip unnecessary call
         LA    R1,ISPCDRPL             Point to ISPLINK plist
         L     R15,ISPLNKAD            Load ISPLINK entry point
         BASR  R14,R15                 Call ISPLINK
ISPFRETN DS    0H
         DELETE EPLOC=DOUBLE
ISPFEXIT DS    0H
         CL    R4,FOURKLEN             Return code higher than 4?
         BNH   SPFMSGOK                No, skip message set up
         MVI   MSG,22                  ISPF error ##
         L     R15,=A(REVMSGS)
         BASR  R14,R15                 Fetch message text
         CVD   R4,DOUBLE
         OI    DOUBLE+7,X'0F'
         UNPK  MSG+13(2),DOUBLE+6(2)
SPFMSGOK ST    R4,DOUBLE               Save the return code to return
         NI    PICFLAGS,255-PICOK      Redraw of any picture required
         NI    STATUS4,255-$4ATTN      Reset attention flag
         OI    STATUS7,$7RESHO         Ensure correct size is set
         LA    R0,$SPFWKLN             Load length of DSA
         LR    R1,R13                  Prepare for FREEMAIN
         L     R13,4(,R13)             Point to callers savearea
         OI    11(R13),X'01'           Invalidate forward pointer
         FREEMAIN R,LV=(0),A=(1)       Free DSA
         LM    R14,R12,12(R13)         Restore caller's registers
         L     R15,DOUBLE              Set correct return code
         BR    R14                     Return to caller

MDSN     MVC   EDATASET+1(0),4(R1)     <<< Executed >>>

**********************************************************************
*                                                          *         *
*         HANDLE HIERARCHICAL FILE SYSTEM REQUESTS         *  GP@HC  *
*                                                          * 10/2000 *
**********************************************************************

ISPFHFS  LA    R1,ISPCERPL             Point to ISPLINK plist
         L     R15,ISPLNKAD            Load ISPLINK entry point
         BASR  R14,R15                 Call ISPLINK

         L     R4,4(,R13)              Point to @HDSDYN
         USING @HFSDYN,R4
         L     R15,ISPLNKAD            Load ISPLINK entry point
         CALL  (15),(VDEFINE,HFSCWD,$DIRNAME,CHAR,$DIRNMLN),           +
               VL,MF=(E,SPFPLIST)      VDEFINE HFSCWD
         LTR   R15,R15                 Success?
         BNZ   SPFHFSBD                No

         L     R15,ISPLNKAD            Load ISPLINK entry point
         CALL  (15),(VPUT,HFSCWD,PROFILE),                             +
               VL,MF=(E,SPFPLIST)      UPDATE HFSCWD
         LTR   R15,R15                 Success?
         BNZ   SPFHFSBD                No

         L     R15,ISPLNKAD            Load ISPLINK entry point
         CALL  (15),(VDELETE,HFSCWD),                                  +
               VL,MF=(E,SPFPLIST)      VDELETE HFSCWD
         LTR   R15,R15                 Success?
         BNZ   SPFHFSBD                No

         LH    R0,SELENTNM             Get file name length
         ST    R0,EDATASET             Save it in a word
         L     R15,ISPLNKAD            Load ISPLINK entry point
         CALL  (15),(VDEFINE,HFSNAME,SELENTNM+2,CHAR,EDATASET),        +
               VL,MF=(E,SPFPLIST)      VDEFINE HFSNAME
         LTR   R15,R15                 Success?
         BNZ   SPFHFSBD                No

         L     R15,ISPLNKAD            Load ISPLINK entry point
         CALL  (15),(VPUT,HFSNAME,SHARED),                             +
               VL,MF=(E,SPFPLIST)      UPDATE HFSNAME
         LTR   R15,R15                 Success?
         BNZ   SPFHFSBD                No

         L     R15,ISPLNKAD            Load ISPLINK entry point
         CALL  (15),(VDELETE,HFSNAME),                                 +
               VL,MF=(E,SPFPLIST)      VDELETE HFSNAME
         LTR   R15,R15                 Success?
         BNZ   SPFHFSBD                No

         BAS   R14,SPFSETRL            Go set browse record length
         LA    R15,SELECT
         LA    R0,SELCMDLN
         LA    R1,HFEDCMD
         CLI   0(R5),C'B'              Can't interest you in browse?
         BNE   *+8                     No
         LA    R1,HFBRCMD              Yes
         STM   R15,R1,SPFPLIST
         OI    SPFPLIST+8,X'80'
         B     ISPFFILE                Go do the deed

SPFSETRL CLI   0(R5),C'B'              Intending to invoke browse?
         BNER  R14                     No, do nothing here
         ST    R14,DOWNR               Save return address

         CLI   UFILESIZ+3,X'00'        File size a multiple of 4K?
         BNE   SPFCLRRL                No
         TM    UFILESIZ+2,X'0F'        File size a multiple of 4K?
         BNZ   SPFCLRRL                No

         L     R15,ISPLNKAD            Load ISPLINK entry point
         CALL  (15),(VDEFINE,HFSRL,CHAR4096,CHAR,FOURKLEN),            +
               VL,MF=(E,SPFPLIST)      VDEFINE HFSRL
         LTR   R15,R15                 Success?
         BNZ   SPFHFSBD                No
         B     SPFRLOK

SPFCLRRL L     R15,ISPLNKAD            Load ISPLINK entry point
         CALL  (15),(VDEFINE,HFSRL,CHARBLNK,CHAR,BLANKLEN),            +
               VL,MF=(E,SPFPLIST)      VDEFINE HFSRL
         LTR   R15,R15                 Success?
         BNZ   SPFHFSBD                No

SPFRLOK  L     R15,ISPLNKAD            Load ISPLINK entry point
         CALL  (15),(VPUT,HFSRL,SHARED),                               +
               VL,MF=(E,SPFPLIST)      UPDATE HFSRL
         LTR   R15,R15                 Success?
         BNZ   SPFHFSBD                No

         L     R15,ISPLNKAD            Load ISPLINK entry point
         CALL  (15),(VDELETE,HFSRL),                                   +
               VL,MF=(E,SPFPLIST)      VDELETE HFSRL
         LTR   R15,R15                 Success?
         BNZ   SPFHFSBD                No

         L     R14,DOWNR               Restore return address
         BR    R14

         DROP  R4                      @HFSDYN
         DROP  R11,R13                 REVISPF, @SPFWORK
         TITLE '  R E V I S P F   -   S T A T I C   A R E A  '
ISPCDRPL DC    A(CONTROL)
         DC    A(DISPLAY)
         DC    A(REFRESH+HIGH_BIT)
ISPCERPL DC    A(CONTROL)
         DC    A(ERRORS)
         DC    A(RETURN+HIGH_BIT)
ISPLNKNM DC    CL8'ISPLINK '
PFDLNKNM DC    CL8'PFDLINKX'
BRWSCMD  DC    CL8'BROWSE  '
EDITCMD  DC    CL8'EDIT    '
VIEWCMD  DC    CL8'VIEW    '
CONTROL  DC    CL8'CONTROL '
DISPLAY  DC    CL8'DISPLAY '
REFRESH  DC    CL8'REFRESH '
ERRORS   DC    CL8'ERRORS  '
RETURN   DC    CL8'RETURN  '
VDEFINE  DC    CL8'VDEFINE '
VDELETE  DC    CL8'VDELETE '
VPUT     DC    CL8'VPUT    '
CHAR     DC    CL8'CHAR    '
HFSCWD   DC    CL8'HFSCWD  '
HFSNAME  DC    CL8'HFSNAME '
HFSRL    DC    CL8'HFSRL   '
SELECT   DC    CL8'SELECT  '
SHARED   DC    CL8'SHARED  '
PROFILE  DC    CL8'PROFILE '
CHAR4096 DC    CL4'4096'
CHARBLNK DC    CL4'    '
HFEDCMD  DC    CL16'CMD(BPXWEDIT)'
HFBRCMD  DC    CL16'CMD(BPXWBRWS)'
         AIF   (NOT &ENVZV2).GENMEM3
VCOPY    DC    CL8'VCOPY   '
DATIDLST DC    CL10'(REVDATID)'
OPTMOVE  DC    CL6'(MOVE)'
LMINIT   DC    CL8'LMINIT  '
DATID    DC    CL8'DATID   '
DATIDLEN DC    F'8'
.GENMEM3 ANOP
SELCMDLN DC    F'16'
FOURKLEN DC    F'4'
BLANKLEN DC    F'1'
RIGHTBQ  DC    CL3')'' '

         DC    0D'0'
         LTORG

         DC    0D'0'                   End of CSECT
         TITLE '  R E V I S P F   -   D Y N A M I C   A R E A  '
@SPFWORK DSECT
         DS    18F
ISPLNKAD DS    A
SPFPLIST DS    5A
         AIF   (NOT &ENVZV2).GENMEM4
         DS    7A
MEMABGEN DS    F                       Absolute member generation nmbr
REVDATID DS    CL8
.GENMEM4 ANOP
EDATASET DS    CL57
         DS    0D                      End of DSECT
$SPFWKLN EQU   *-@SPFWORK
         TITLE '  R E V H I S T  '
**********************************************************************
*                                                          *         *
*         PROGRAM OBJECT EXTRACT HISTORY DATA              *  GP@HC  *
*                                                          * 09/2000 *
**********************************************************************

**********************************************************************
*                                                                    *
*        This routine receives control from REVIEW2 when a member    *
*        or file is selected with an 'H' (history) or 'M' (module    *
*        map).  REVPDS and REVPDSE will not allow those selection    *
*        codes unless RECFM=U.  A Binder API dialog will be used     *
*        to acquire the requested data.  The Binder Fast Data        *
*        Access programming interface is now no longer used so       *
*        that the same logic can be used for all load module and     *
*        program object types.                                       *
*                                                                    *
*        For an 'H' selection, the four classes of IDR data are      *
*        retrieved and formatted using the "*OBJHIST" built-in       *
*        format to provide column headings.                          *
*                                                                    *
*        For an 'M' selection the available data depends on the      *
*        type of program being examined.                             *
*                                                                    *
*        For load modules and level-1 program objects (PO1) ESD      *
*        information is displayed using the "*OBJESD*" built-in      *
*        format, and for other PDSE and UNIX program objects MAP     *
*        information is displayed using the "*OBJMAP*" built-in      *
*        format.                                                     *
*                                                                    *
**********************************************************************

**********************************************************************
*                                                                    *
* Registers on entry: R4 -> Open BPAM DCB                            *
*                     R9 -> @DATA                                    *
*                     R13-> Register save area (@DATA)               *
*                     R14-> Return address                           *
*                     R15-> REVHIST                                  *
*                                                                    *
* During processing:  R13-> GETMAINed area                           *
*                                                                    *
* Return codes:       R15 = 0  Processing complete                   *
*                     R15 = 8  Could not initialize                  *
*                                                                    *
**********************************************************************

REVHIST  CSECT
REVHIST  AMODE 31
         B     @HIST-*(,R15)
         DC    AL1(7),CL7'REVHIST'
@HIST    STM   R14,R12,12(R13)
         LR    R10,R15
         LA    R15,1
         LA    R11,4095(R15,R10)
         USING REVHIST,R10,R11
         NI    MODE,255-MD_FMT     Reset formatting
         CLI   OSBITS,X'9B'        MVS/ESA or later?
         BNE   HistNoXA            No, no Bimder API available
         L     R0,@HSTWKSZ         Yes, acquire working storage
         MVI   GETMNTRC,91         Track GETMAIN in case of failure
         GETMAIN RC,LV=(0),LOC=(31,64)   Get main storage
         LTR   R15,R15             Success?
         BZ    @HISTOK             Yes
         MVI   MSG,102             "REVIEW" internal storage exhausted
         B     HistNoOp            Go return

@HISTOK  LR    R14,R1              Point to the new area
         L     R15,@HSTWKSZ        Get its size
         SR    R3,R3               Zero pad and source length
         MVCL  R14,R2              Clear working storage
         ST    R1,8(,R13)          Chain save areas
         ST    R13,4(,R1)
         LR    R13,R1              Point to GETMAINed area
         USING @HSTWORK,R13

         MVI   STARTD+1,1          Set Binder dialog function codes
         MVI   CREATEW+1,10
         MVI   INCLUDE+1,40
         MVI   GETD+1,61
         MVI   DELETEW+1,15
         MVI   ENDD+1,5

         LA    R0,1                Start with version 1
         TM    STATUS9,$9_M        'M' selection code used?
         BO    *+8                 Yes, try ESD version 1 for MAP
         LA    R0,3                No, use version 3 for IDRs
         STH   R0,STARTD+2         Complete dialog function codes
         STH   R0,CREATEW+2
         STH   R0,INCLUDE+2
         STH   R0,GETD+2
         STH   R0,DELETEW+2
         STH   R0,ENDD+2

         TM    $UCBAD,$HFSIO       Processing HFS program object?
         BO    HstStart            Yes, jump over PDS/PDSE stuff

         CLI   $DDNAML+1,0         Length of $DDNAME set?
         BNE   *+8                 Yes
         MVI   $DDNAML+1,8         No, but it is probably eight
         MVI   HistMem+1,8         Say 8-byte member name
         MVC   HistMem+2(8),$MEMBER

         CLI   $CONCAT,0           In concatenated library?
         BNE   HstStart            Yes, better call API
         TM    DS1SMSFG,DS1PDSE    Is data set a PDSE?
         BZ    HstStart            No
         TM    STATUS9,$9PGMOBJ    Already known to be program object?
         BO    HstStart            Yes, better call API
         MVC   BndData(ISITMGDL),ISITMGDS
         USING ISM,BndData
         ISITMGD DCB=(R4),DATATYPE=YES,MF=(E,BndData)
         TM    ISMOFLG3,ISMDTPGM   Program object library?
         BO    HstStart            Yes, better call API
         MVI   MSG,101             Data set is not a program library
         B     HistExit

*  Start the Dialog
HstStart EQU   *
*        IEWBIND FUNC=STARTD,      Start a Binder dialog
*              VERSION=?,RETCODE=BndRetcd,RSNCODE=BndRsncd,
*              DIALOG=DialgTkn,
*              MF=(E,BndParms,COMPLETE)
         LOAD  EPLOC=IEWBIND       Find the IEWBIND entry point
         ST    R0,DialgTkn         Save the address
         ST    R0,ModToken         Save the address
         LR    R15,R0              Copy the address
         CALL  (15),(STARTD,       Function code                       +
               BndRetcd,           Return code                         +
               BndRsncd,           Reason code                         +
               DialgTkn,           Dialog token                        +
               HistZero,HistZero,HistZero),                            +
               VL,MF=(E,BndParms)
         CLC   BndRetcd,=F'8'      Major failure?
         BH    HstBad              Yes, go report reason code

*  Create the Workmod
*        IEWBIND FUNC=CREATEW,     Create a Workmod
*              VERSION=?,RETCODE=BndRetcd,RSNCODE=BndRsncd,
*              WORKMOD=ModToken,DIALOG=DialgTkn,INTENT=ACCESS,
*              MF=(E,BndParms,COMPLETE)
         L     R15,DialgTkn        Get IEWBIND entry point
         CALL  (15),(CREATEW,      Function code                       +
               BndRetcd,           Return code                         +
               BndRsncd,           Reason code                         +
               DialgTkn,           Dialog token                        +
               ModToken,           Module token                        +
               =C'A'),             Intent (access)                     +
               VL,MF=(E,BndParms)

*  Include the module to be processed
         TM    $UCBAD,$HFSIO       Processing HFS program object?
         BO    HstIncNx            Yes, reference file by path

*        IEWBIND FUNC=INCLUDE,     Include a program object
*              VERSION=?,RETCODE=BndRetcd,RSNCODE=BndRsncd,
*              WORKMOD=ModToken,INTYPE=NAME,
*              DDNAME=$DDNAML,MEMBER=HistMem,
*              MF=(E,BndParms,COMPLETE)
         L     R15,DialgTkn        Get IEWBIND entry point
         CALL  (15),(INCLUDE,      Function code                       +
               BndRetcd,           Return code                         +
               BndRsncd,           Reason code                         +
               ModToken,           Module token                        +
               =C'N',              Intype (name)                       +
               $DDNAML,            Ddname                              +
               HistMem,            Member                              +
               HistZero,HistZero,HistZero,0,                           +
               =C'N',              Attrib                              +
               =C'N'),             Aliases                             +
               VL,MF=(E,BndParms)
         B     HstInc              Go check result

HstIncNx L     R2,$PATHPTR         Point to path name varying string
*        IEWBIND FUNC=INCLUDE,     Include a program object
*              VERSION=?,RETCODE=BndRetcd,RSNCODE=BndRsncd,
*              WORKMOD=ModToken,INTYPE=NAME,PATHNAME=(R2),
*              MF=(E,BndParms,COMPLETE)
         L     R15,DialgTkn        Get IEWBIND entry point
         CALL  (15),(INCLUDE,      Function code                       +
               BndRetcd,           Return code                         +
               BndRsncd,           Reason code                         +
               ModToken,           Module token                        +
               =C'N',              Intype (name)                       +
               (R2),=X'00004040',  Pathname                            +
               HistZero,HistZero,HistZero,0,                           +
               =C'N',              Attrib                              +
               =C'N'),             Aliases                             +
               VL,MF=(E,BndParms)

HstInc   CLC   BndRetcd,=F'4'      Major failure?
         BH    HstBad              Yes, go report reason code

*  Prepare the accumulation area for retrieved data
         LA    R0,16               Get "DIV" entry code (FREEMAIN)
         L     R15,DIVADDRH        Load "DIV" entry point
         BASR  R14,R15             Free any pre-existing "DIV" area
         LA    R0,256
         SLL   R0,10               Get size to request this time
         ST    R0,DIVSZREQ         Set size to request this time
         SR    R0,R0               Get "DIV" entry code (GETMAIN)
         L     R15,DIVADDRH        Load "DIV" entry point
         BASR  R14,R15             Create new "DIV" area
         LTR   R15,R15             Success?
         BNZ   HstNoStg            No
         ST    R15,COUNT           Next record will be the first

*  Decide whether History or Map is requested
         TM    STATUS9,$9_M        'M' selection code used?
         BO    HstMap              Yes, module map requested

         USING IEWBESD,BndData
         USING IEWBMAP,BndData
         USING IEWBIDL,BndData
         USING IEWBIDU,BndData
         USING IEWBIDZ,BndData
         USING IEWBIDB,BndData

*  Extract History - Language translator
         XC    BndCursr,BndCursr   First call for this class
HstRedoL EQU   *
         MVC   IEWBIDL(IDLH_LENG),IDLI_INIT_VALUES
         LA    R3,CLS_IDRL         Point to class name
         BAS   R2,HistGetD         Perform Binder API GETD call
         LA    R6,IEWBIDL+IDLH_LENG
         USING IDL_ENTRY,R6
         ICM   R7,15,BndCount      Get the returned record count
         BNP   HstDoneL            No entries were returned
HstLoopL EQU   *
         MVI   HistRecd,C' '       Clear record buffer
         MVC   HistRecd+1(HistLen),HistRecd
         MVC   HistComp,IDL_PID_ID Copy processor id
         MVC   HistVer,IDL_VERSION
         MVI   HistDot,C'.'
         MVC   HistRel,IDL_MOD_LEVEL
         MVC   HistDate(4),IDL_DATE_PROCESSED     Year
         PACK  DOUBLE,IDL_DATE_PROCESSED
         OI    DOUBLE+7,X'0F'
         L     R4,DOUBLE+4
         L     R15,=A(IDRDATE)
         BASR  R14,R15
         L     R4,MODDCBPT         Restore DCB pointer
         MVC   HistDate+4(6),DOUBLE+2
         LH    R15,IDL_RESIDENT_CHARS
         L     R14,IDL_RESIDENT_PTR
         LA    R0,1024
         CLR   R15,R0
         BNH   *+8
         LA    R15,1024
         LA    R2,HistRecd         Point to record
         LA    R0,HistSect         Point to target
         LR    R1,R15              Copy length
         MVCL  R0,R14              Decrement for execute
         LR    R1,R0               Point past data
         SR    R1,R2               Get record length
         LA    R0,4                Get entry code (record store)
         L     R15,DIVADDRH        Load REVDIV entry point
         BASR  R14,R15             Store the record
         LA    R0,1
         A     R0,COUNT            Increment record count
         ST    R0,COUNT
         A     R6,IDLH_ENTRY_LENG  Point to next returned entry
         BCT   R7,HstLoopL         Process next entry

HstDoneL EQU   *
         ICM   R0,15,BndRetcd      More data to get?
         BZ    HstRedoL            Yes, it seems so
         DROP  R6                  IDL_ENTRY

*  Extract History - User identification
         XC    BndCursr,BndCursr   First call for this class
HstRedoU EQU   *
         MVC   IEWBIDU(IDUH_LENG),IDUI_INIT_VALUES
         LA    R3,CLS_IDRU         Point to class name
         BAS   R2,HistGetD         Perform Binder API GETD call
         LA    R6,IEWBIDU+IDUH_LENG
         USING IDU_ENTRY,R6
         ICM   R7,15,BndCount      Get the returned record count
         BNP   HstDoneU            No entries were returned
HstLoopU EQU   *
         MVI   HistRecd,C' '       Clear record buffer
         MVC   HistRecd+1(HistLen),HistRecd
         LH    R14,IDU_DATA_CHARS
         LA    R15,IDU_DATA
         LA    R0,14
         CLR   R14,R0
         BNH   *+8
         LA    R14,14
         BCTR  R14,0               Decrement for execute
         EX    R14,HstLdUsr
         MVC   HistDate(4),IDU_CREATE_DATE        Year
         PACK  DOUBLE,IDU_CREATE_DATE
         OI    DOUBLE+7,X'0F'
         L     R4,DOUBLE+4
         L     R15,=A(IDRDATE)
         BASR  R14,R15
         L     R4,MODDCBPT         Restore DCB pointer
         MVC   HistDate+4(6),DOUBLE+2
         LH    R15,IDU_RESIDENT_CHARS
         L     R14,IDU_RESIDENT_PTR
         LA    R0,1024
         CLR   R15,R0
         BNH   *+8
         LA    R15,1024
         LA    R2,HistRecd         Point to record
         LA    R0,HistSect         Point to target
         LR    R1,R15              Copy length
         MVCL  R0,R14              Decrement for execute
         LR    R1,R0               Point past data
         SR    R1,R2               Get record length
         LA    R0,4                Get entry code (record store)
         L     R15,DIVADDRH        Load REVDIV entry point
         BASR  R14,R15             Store the record
         LA    R0,1
         A     R0,COUNT            Increment record count
         ST    R0,COUNT
         A     R6,IDUH_ENTRY_LENG  Point to next returned entry
         BCT   R7,HstLoopU         Process next entry
         DROP  R6                  IDU_ENTRY
HstDoneU EQU   *
         ICM   R0,15,BndRetcd      More data to get?
         BZ    HstRedoU            Yes, it seems so

*  Extract History - Zap
         XC    BndCursr,BndCursr   First call for this class
HstRedoZ EQU   *
         MVC   IEWBIDZ(IDZH_LENG),IDZI_INIT_VALUES
         LA    R3,CLS_IDRZ         Point to class name
         BAS   R2,HistGetD         Perform Binder API GETD call
         LA    R6,IEWBIDZ+IDZH_LENG
         USING IDZ_ENTRY,R6
         ICM   R7,15,BndCount      Get the returned record count
         BNP   HstDoneZ            No entries were returned
HstLoopZ EQU   *
         MVI   HistRecd,C' '       Clear record buffer
         MVC   HistRecd+1(HistLen),HistRecd
         MVC   HistZap,IDZ_ZAP_DATA
         MVC   HistVer(5),=C'(ZAP)'
         MVC   HistDate(4),IDZ_DATE               Year
         PACK  DOUBLE,IDZ_DATE
         OI    DOUBLE+7,X'0F'
         L     R4,DOUBLE+4
         L     R15,=A(IDRDATE)
         BASR  R14,R15
         L     R4,MODDCBPT         Restore DCB pointer
         MVC   HistDate+4(6),DOUBLE+2
         LH    R15,IDZ_RESIDENT_CHARS
         L     R14,IDZ_RESIDENT_PTR
         LA    R0,1024
         CLR   R15,R0
         BNH   *+8
         LA    R15,1024
         LA    R2,HistRecd         Point to record
         LA    R0,HistSect         Point to target
         LR    R1,R15              Copy length
         MVCL  R0,R14              Decrement for execute
         LR    R1,R0               Point past data
         SR    R1,R2               Get record length
         LA    R0,4                Get entry code (record store)
         L     R15,DIVADDRH        Load REVDIV entry point
         BASR  R14,R15             Store the record
         LA    R0,1
         A     R0,COUNT            Increment record count
         ST    R0,COUNT
         A     R6,IDZH_ENTRY_LENG  Point to next returned entry
         BCT   R7,HstLoopZ         Process next entry
         DROP  R6                  IDZ_ENTRY
HstDoneZ EQU   *
         ICM   R0,15,BndRetcd      More data to get?
         BZ    HstRedoZ            Yes, it seems so

*  Extract History - Bind
         XC    BndCursr,BndCursr   First call for this class
         MVC   IEWBIDB(IDBH_LENG),IDBI_INIT_VALUES
         LA    R3,CLS_IDRB         Point to class name
         BAS   R2,HistGetD         Perform Binder API GETD call
         LA    R6,IEWBIDB+IDBH_LENG
         USING IDB_ENTRY,R6
         ICM   R7,15,BndCount      Get the returned record count
         BNP   HstDoneB            No entries were returned
HstLoopB EQU   *
         MVI   HistRecd,C' '       Clear record buffer
         MVC   HistRecd+1(HistLen),HistRecd
         MVC   HistComp,IDB_BINDER_ID
         MVC   HistVer,IDB_VERSION
         MVI   HistDot,C'.'
         MVC   HistRel,IDB_RELEASE
         MVC   HistDate(4),IDB_DATE_BOUND         Year
         PACK  DOUBLE,IDB_DATE_BOUND
         OI    DOUBLE+7,X'0F'
         L     R4,DOUBLE+4
         L     R15,=A(IDRDATE)
         BASR  R14,R15
         L     R4,MODDCBPT         Restore DCB pointer
         MVC   HistDate+4(6),DOUBLE+2
         MVC   HistTime(2),IDB_TIME_BOUND
         MVI   HistTime+2,C':'
         MVC   HistTime+3(2),IDB_TIME_BOUND+2
         MVI   HistTime+5,C':'
         MVC   HistTime+6(2),IDB_TIME_BOUND+4
         LA    R1,IDB_MODULE_SIZE  Point to hex number
         LA    R15,HistSize        Point to display area
         BAS   R14,HistHex#        Show hex number
         LH    R15,IDB_CALLERID_CHARS
         LA    R14,IDB_CALLERID
         LA    R0,1024
         CLR   R15,R0
         BNH   *+8
         LA    R15,1024
         LA    R2,HistRecd         Point to record
         LA    R0,HistSect         Point to target
         LR    R1,R15              Copy length
         MVCL  R0,R14              Decrement for execute
         LR    R1,R0               Point past data
         SR    R1,R2               Get record length
         LA    R0,4                Get entry code (record store)
         L     R15,DIVADDRH        Load REVDIV entry point
         BASR  R14,R15             Store the record
         LA    R0,1
         A     R0,COUNT            Increment record count
         ST    R0,COUNT
         A     R6,IDBH_ENTRY_LENG  Point to next returned entry
         BCT   R7,HstLoopB         Process next entry
         DROP  R6                  IDB_ENTRY
HstDoneB EQU   *
         B     HstDelWm            History data collection complete


HstMap   EQU   *                   Process module map request

*  Extract ESD data for load modules and compatible objects
         XC    BndCursr,BndCursr   First call for this class
ESD_Redo EQU   *
         MVC   IEWBESD(ESDH_LENG),ESDI_INIT_VALUES
         LA    R3,CLS_ESD          Point to class name
         BAS   R2,HistGetD         Perform Binder API GETD call
         LA    R6,IEWBESD+ESDH_LENG
         USING ESD_ENTRY,R6
         ICM   R7,15,BndCount      Get the returned record count
         BNP   ESD_Done            No entries were returned
ESD_Loop EQU   *
         CLI   ESD_SCOPE,C'L'      External reference?
         BE    Esd_Next            Yes, suppress its display
         MVI   EsdRecd,C' '        Clear record buffer
         MVC   EsdRecd+1(255),EsdRecd
         SR    R1,R1
         ICM   R1,3,ESD_SEGMENT
         CVD   R1,DOUBLE
         MVC   EsdSeg,=X'2020202120'  (Reuse literal)
         ED    EsdSeg-1(4),DOUBLE+6
         SR    R1,R1
         IC    R1,ESD_ALIGN
         LA    R0,1
         SLL   R0,0(R1)
         CVD   R0,DOUBLE
         MVC   EsdAlign,=X'2020202120'
         ED    EsdAlign-1(6),DOUBLE+5
         MVC   EsdType(2),ESD_TYPE
         OC    EsdType+3(1),ESD_SCOPE
         OC    EsdType+5(1),ESD_TEXT
         TM    ESD_STORAGE,X'10'   Read-only storage?
         BNO   *+10                No
         MVC   EsdStg,=C'R-O'      Yes, flag it
         IC    R1,ESD_USABILITY
         SLL   R1,2
         LA    R2,HSTREUSE(R1)
         MVC   EsdReuse,0(2)
         IC    R1,ESD_RMODE
         SLL   R1,2
         LA    R2,HSTMODES(R1)
         MVC   EsdRmode,0(2)
         IC    R1,ESD_AMODE
         SLL   R1,2
         LA    R2,HSTMODES(R1)
         MVC   EsdAmode,0(2)
         LA    R1,ESD_MODULE_OFFSET Point to hex number
         LA    R15,EsdOfst         Point to display area
         BAS   R14,HistHex#        Show hex number
         ICM   R0,15,ESD_LENG      Any length?
         BZ    ESD_SzOk            No
         LA    R1,ESD_LENG         Point to hex number
         LA    R15,EsdSize         Point to display area
         BAS   R14,HistHex#        Show hex number
ESD_SzOk EQU   *
         LA    R0,EsdName          Point to where name would go
         LH    R15,ESD_NAME_CHARS
         LTR   R15,R15             Any name?
         BNP   ESD_NmOk            No
         LA    R1,1024
         CLR   R15,R1
         BNH   *+6
         LR    R15,R1
         L     R14,ESD_NAME_PTR    Yes, point to it
         CLI   0(R14),C' '         Displayable?
         BH    ESD_NmGd            Yes
         LA    R1,510
         CLR   R15,R1
         BNH   *+6
         LR    R15,R1
         MVC   EsdName(2),=C'X'''
         LA    R1,EsdName+2
ESD_NmLp EQU   *
         UNPK  0(3,R1),0(2,R14)    Show name in hex
         TR    0(2,R1),HSTHEX-C'0'
         LA    R14,1(,R14)
         LA    R1,2(,R1)
         BCT   R15,ESD_NmLp
         MVI   0(R1),QUOTE
         LA    R0,1(,R1)
         B     ESD_NmOk
ESD_NmGd EQU   *
         LR    R1,R15              Copy length
         MVCL  R0,R14
ESD_NmOk EQU   *
         LR    R1,R0               Point past data
         LA    R2,EsdRecd          Point to record
         SR    R1,R2               Get record length
         LA    R0,4                Get entry code (record store)
         L     R15,DIVADDRH        Load REVDIV entry point
         BASR  R14,R15             Store the record
         LA    R0,1
         A     R0,COUNT            Increment record count
         ST    R0,COUNT
ESD_Next EQU   *
         A     R6,ESDH_ENTRY_LENG  Point to next returned entry
         BCT   R7,ESD_Loop         Process next entry
         DROP  R6                  ESD_ENTRY
ESD_Done EQU   *
         ICM   R0,15,BndRetcd      More data to get?
         BZ    ESD_Redo            Yes, it seems so

*  Delete the Workmod
HstDelWm EQU   *
*        IEWBIND FUNC=DELETEW,     Delete the Workmod
*              VERSION=?,RETCODE=BndRetcd,RSNCODE=BndRsncd,
*              WORKMOD=ModToken,PROTECT=NO,
*              MF=(E,BndParms,COMPLETE)
         L     R15,DialgTkn        Get IEWBIND entry point
         CALL  (15),(DELETEW,      Function code                       +
               BndRetcd,           Return code                         +
               BndRsncd,           Reason code                         +
               ModToken,           Dialog token                        +
               =C'N'),             Protect                             +
               VL,MF=(E,BndParms)

*  End the Dialog
         L     R2,DialgTkn         Save IEWBIND address
*        IEWBIND FUNC=ENDD,        End the Binder dialog
*              VERSION=?,RETCODE=BndRetcd,RSNCODE=BndRsncd,
*              DIALOG=DialgTkn,PROTECT=NO,
*              MF=(E,BndParms,COMPLETE)
         L     R15,DialgTkn        Get IEWBIND entry point
         CALL  (15),(ENDD,         Function code                       +
               BndRetcd,           Return code                         +
               BndRsncd,           Reason code                         +
               DialgTkn,           Dialog token                        +
               =C'N'),             Protect                             +
               VL,MF=(E,BndParms)

*  Determine if any data extracted at this stage
         ICM   R0,15,COUNT         Some data collected?
         BP    HstFmt              Yes, go activate formatting
         TM    STATUS9,$9_M        'M' selection code used?
         BNO   Hst0Chek            No, no history data available
         TM    FDADEL,HistMap      Failure in retry phase?
         BO    Hst0Chek            Yes, give up

*  Set up Binder API call codes for a later version
         LA    R0,5                Use version 5 for MAP
         STH   R0,STARTD+2         Complete dialog function codes
         STH   R0,CREATEW+2
         STH   R0,INCLUDE+2
         STH   R0,GETD+2
         STH   R0,DELETEW+2
         STH   R0,ENDD+2
         OI    FDADEL,HistMap      Flag MAP retry phase
         MVC   MSG(4),HistZero     Clear message from ESD call
         NI    STATUS7,255-$7BELL  Reset audible alarm

*  Start another Dialog
*        IEWBIND FUNC=STARTD,      Start a Binder dialog
*              VERSION=?,RETCODE=BndRetcd,RSNCODE=BndRsncd,
*              DIALOG=DialgTkn,
*              MF=(E,BndParms,COMPLETE)
         XC    DialgTkn,DialgTkn   Reset the dialog token
         ST    R2,DialgTkn         Save the IEWBIND entry point
         MVC   ModToken,DialgTkn   Prepare the module token
         LR    R15,R2              Copy the address
         CALL  (15),(STARTD,       Function code                       +
               BndRetcd,           Return code                         +
               BndRsncd,           Reason code                         +
               DialgTkn,           Dialog token                        +
               HistZero,HistZero,HistZero),                            +
               VL,MF=(E,BndParms)
         CLC   BndRetcd,=F'8'      Major failure?
         BH    HstBad              Yes, go report reason code

*  Create another Workmod
*        IEWBIND FUNC=CREATEW,     Create a Workmod
*              VERSION=?,RETCODE=BndRetcd,RSNCODE=BndRsncd,
*              WORKMOD=ModToken,DIALOG=DialgTkn,INTENT=ACCESS,
*              MF=(E,BndParms,COMPLETE)
         L     R15,DialgTkn        Get IEWBIND entry point
         CALL  (15),(CREATEW,      Function code                       +
               BndRetcd,           Return code                         +
               BndRsncd,           Reason code                         +
               DialgTkn,           Dialog token                        +
               ModToken,           Module token                        +
               =C'A'),             Intent (access)                     +
               VL,MF=(E,BndParms)

*  Include the module to be processed (again)
         TM    $UCBAD,$HFSIO       Processing HFS program object?
         BO    HstIncNy            Yes, reference file by path

*        IEWBIND FUNC=INCLUDE,     Include a program object
*              VERSION=?,RETCODE=BndRetcd,RSNCODE=BndRsncd,
*              WORKMOD=ModToken,INTYPE=NAME,
*              DDNAME=$DDNAML,MEMBER=HistMem,
*              MF=(E,BndParms,COMPLETE)
         L     R15,DialgTkn        Get IEWBIND entry point
         CALL  (15),(INCLUDE,      Function code                       +
               BndRetcd,           Return code                         +
               BndRsncd,           Reason code                         +
               ModToken,           Module token                        +
               =C'N',              Intype (name)                       +
               $DDNAML,            Ddname                              +
               HistMem,            Member                              +
               HistZero,HistZero,HistZero,0,                           +
               =C'N',              Attrib                              +
               =C'N'),             Aliases                             +
               VL,MF=(E,BndParms)
         B     HstIncMp            Go check result

HstIncNy L     R2,$PATHPTR         Point to path name varying string
*        IEWBIND FUNC=INCLUDE,     Include a program object
*              VERSION=?,RETCODE=BndRetcd,RSNCODE=BndRsncd,
*              WORKMOD=ModToken,INTYPE=NAME,PATHNAME=(R2),
*              MF=(E,BndParms,COMPLETE)
         L     R15,DialgTkn        Get IEWBIND entry point
         CALL  (15),(INCLUDE,      Function code                       +
               BndRetcd,           Return code                         +
               BndRsncd,           Reason code                         +
               ModToken,           Module token                        +
               =C'N',              Intype (name)                       +
               (R2),=X'00004040',  Pathname                            +
               HistZero,HistZero,HistZero,0,                           +
               =C'N',              Attrib                              +
               =C'N'),             Aliases                             +
               VL,MF=(E,BndParms)

HstIncMp CLC   BndRetcd,=F'4'      Major failure?
         BH    HstBad              Yes, go report reason code

*  Extract MAP data for non-migratable program objects
         XC    BndCursr,BndCursr   First call for this class
MAP_Redo EQU   *
         MVC   IEWBMAP(MAPH_LENG),MAPI_INIT_VALUES
         LA    R3,CLS_MAP          Point to class name
         BAS   R2,HistGetD         Perform Binder API GETD call
         LA    R6,IEWBMAP+MAPH_LENG
         USING MAP_ENTRY,R6
         ICM   R7,15,BndCount      Get the returned record count
         BNP   MAP_Done            No entries were returned
MAP_Loop EQU   *
         CLI   MAP_TYPE,0          Null entry?
         BE    MAP_Done            Yes, end of data
         MVI   MSG,0               Clear pending message
         MVI   MapRecd,C' '        Clear record buffer
         MVC   MapRecd+1(255),MapRecd
         UNPK  MapFlags(3),MAP_FLAGS(2)
         TR    MapFlags,HSTHEX-C'0'
         MVI   MapFlags+2,C' '
         MVC   MapType+2(1),MAP_TYPE
         CLI   MAP_TYPE,C'L'       Label within section?
         BE    MAP_TpOk            Yes
         CLI   MAP_TYPE,C'X'       Text extent within section or part?
         BE    MAP_TpOk            Yes
         MVC   MapType+1(2),MapType+2
         CLI   MAP_TYPE,C'S'       Section within class?
         BE    MAP_TpOk            Yes
         CLI   MAP_TYPE,C'P'       Part within class?
         BE    MAP_TpOk            Yes
         MVC   MapType(2),MapType+1
         ICM   R0,15,MAP_OFFSET    Any offset?
         BZ    MAP_OfOk            No
MAP_TpOk EQU   *
         LA    R1,MAP_OFFSET       Point to hex number
         LA    R15,MapOfst         Point to display area
         BAS   R14,HistHex#        Show hex number
MAP_OfOk EQU   *
         ICM   R0,15,MAP_QUANTITY  Any quantity?
         BZ    MAP_SzOk            No
         LA    R1,MAP_QUANTITY     Point to hex number
         LA    R15,MapSize         Point to display area
         BAS   R14,HistHex#        Show hex number
MAP_SzOk EQU   *
         LA    R0,MapName          Point to where name would go
         LH    R15,MAP_NAME_CHARS
         LTR   R15,R15             Any name?
         BNP   MAP_NmOk            No
         LA    R1,1024
         CLR   R15,R1
         BNH   *+6
         LR    R15,R1
         L     R14,MAP_NAME_PTR    Yes, point to it
         CLI   0(R14),C' '         Displayable?
         BH    MAP_NmGd            Yes
         LA    R1,510
         CLR   R15,R1
         BNH   *+6
         LR    R15,R1
         MVC   MapName(2),=C'X'''
         LA    R1,MapName+2
MAP_NmLp EQU   *
         UNPK  0(3,R1),0(2,R14)    Show name in hex
         TR    0(2,R1),HSTHEX-C'0'
         LA    R14,1(,R14)
         LA    R1,2(,R1)
         BCT   R15,MAP_NmLp
         MVI   0(R1),QUOTE
         LA    R0,1(,R1)
         B     MAP_NmOk
MAP_NmGd EQU   *
         LR    R1,R15              Copy length
         MVCL  R0,R14
MAP_NmOk EQU   *
         LR    R1,R0               Point past data
         LA    R2,MapRecd          Point to record
         SR    R1,R2               Get record length
         LA    R0,4                Get entry code (record store)
         L     R15,DIVADDRH        Load REVDIV entry point
         BASR  R14,R15             Store the record
         LA    R0,1
         A     R0,COUNT            Increment record count
         ST    R0,COUNT
         A     R6,MAPH_ENTRY_LENG  Point to next returned entry
         BCT   R7,MAP_Loop         Process next entry
         DROP  R6                  MAP_ENTRY
MAP_Done EQU   *
         ICM   R0,15,BndRetcd      More data to get?
         BZ    MAP_Redo            Yes, it seems so

*  Delete the Workmod again
*        IEWBIND FUNC=DELETEW,     Delete the Workmod
*              VERSION=?,RETCODE=BndRetcd,RSNCODE=BndRsncd,
*              WORKMOD=ModToken,PROTECT=NO,
*              MF=(E,BndParms,COMPLETE)
         L     R15,DialgTkn        Get IEWBIND entry point
         CALL  (15),(DELETEW,      Function code                       +
               BndRetcd,           Return code                         +
               BndRsncd,           Reason code                         +
               ModToken,           Dialog token                        +
               =C'N'),             Protect                             +
               VL,MF=(E,BndParms)

*  End the Dialog again
         L     R2,DialgTkn         Save IEWBIND address
*        IEWBIND FUNC=ENDD,        End the Binder dialog
*              VERSION=?,RETCODE=BndRetcd,RSNCODE=BndRsncd,
*              DIALOG=DialgTkn,PROTECT=NO,
*              MF=(E,BndParms,COMPLETE)
         L     R15,DialgTkn        Get IEWBIND entry point
         CALL  (15),(ENDD,         Function code                       +
               BndRetcd,           Return code                         +
               BndRsncd,           Reason code                         +
               DialgTkn,           Dialog token                        +
               =C'N'),             Protect                             +
               VL,MF=(E,BndParms)

*  Determine if any data extracted at this stage
         ICM   R0,15,COUNT         Any data collected?
         BNP   Hst0Chek            No, no data available

*  Set up formatting of collected data
HstFmt   EQU   *
         SR    R1,R1               Retrieval of data now complete
         BCTR  R1,0                Flag end-of-file
         LA    R0,4                Get entry code (record store)
         L     R15,DIVADDRH        Load REVDIV entry point
         BASR  R14,R15             Store the last record
         L     R15,CHKPTTOP        Flag non-empty fully read data set
         XC    0(2*CHKPTLN,R15),0(R15)
         LA    R15,CHKPTLN(,R15)
         ST    R1,0(,R15)          Indicate have read end-of-file
         ST    R15,CHKPTBOT
         ICM   R1,15,FMTAREA       Format area already created?
         BNZ   HstFmtOk            Yes, use it
         L     R0,HSTFMTSZ         Get format area subpool and size
         LR    R2,R0               Copy this subpool and size
         MVI   GETMNTRC,92         Track GETMAIN in case of failure
         GETMAIN R,LV=(0)
         ST    R1,FMTAREA          Point to this area from @DATA
         USING @FMTAREA,R1
         ST    R2,FMTSIZE          Save subpool and size of this area
HstFmtOk EQU   *
         TM    STATUS9,$9_M        MAP request?
         BNO   HstFmHst            No, history
         TM    FDADEL,HistMap      MAP data present?
         BO    HstFmMap            Yes, set up its formatting
         MVC   FMTFELS(ESDFELEN),ESDFELS
         L     R15,SCRNCOLS        Get the screen width
         LA    R0,52
         SR    R15,R0              Get the symbol length which will fit
         STH   R15,FMTFELS+ESDFELEN-6
         STH   R15,FMTFELS+ESDFELEN-4
         LA    R15,FMTFELS
         LA    R15,ESDFELEN(,R15)
         ST    R15,FMTFELAD        Indicate used FELs
         MVC   FMTNAME,=C'*OBJESD*'
         B     HstFmtOn
HstFmMap EQU   *
         MVC   FMTFELS(MAPFELEN),MAPFELS
         L     R15,SCRNCOLS        Get the screen width
         LA    R0,28
         SR    R15,R0              Get the symbol length which will fit
         STH   R15,FMTFELS+MAPFELEN-6
         STH   R15,FMTFELS+MAPFELEN-4
         LA    R15,FMTFELS
         LA    R15,MAPFELEN(,R15)
         ST    R15,FMTFELAD        Indicate used FELs
         MVC   FMTNAME,=C'*OBJMAP*'
         B     HstFmtOn
HstFmHst EQU   *
         MVC   FMTFELS(HSTFELEN),HSTFELS
         L     R15,SCRNCOLS        Get the screen width
         LA    R0,50
         SR    R15,R0              Get the symbol length which will fit
         STH   R15,FMTFELS+HSTFELEN-6
         STH   R15,FMTFELS+HSTFELEN-4
         LA    R15,FMTFELS
         LA    R15,HSTFELEN(,R15)
         ST    R15,FMTFELAD        Indicate used FELs
         MVC   FMTNAME,=C'*OBJHIST'
         DROP  R1                  @FMTAREA
HstFmtOn OI    MODE,MD_FMT         Enable formatting
         NI    MODE,255-MD_ASCII-MD_HEX
         OI    STATUS9,$9HIST      Flag history data display mode
         NI    STATUS2,255-$2FAST  Disable "fastpath"
         B     HistTerm

Hst0Chek EQU   *
         CLI   MSG,0               Any message loaded?
         BE    HistTerm            Yes, do not overlay it
         MVI   MSG,132             No data of requested type exists

HistTerm EQU   *
         DELETE EPLOC=IEWBIND      Finished with IEWBIND
HistExit EQU   *
         L     R0,@HSTWKSZ         Get dynamic storage size
         LR    R1,R13              Point to dynamic area to be freed
         L     R13,4(,R13)         Point to previous save area
         FREEMAIN RU,LV=(0),A=(1)  Free @HSTWORK
HistNoOp LM    R14,R12,12(R13)     Restore registers
         SR    R15,R15             Flag success
         ST    R15,COUNT           Show from first entry
         BR    R14                 Return to caller

HistNoXA LA    R0,240              Show load module history details
         A     R0,SCRNCOLS
         ST    R0,OFFSET
         LM    R14,R12,12(R13)     Restore registers
         SR    R15,R15             Flag success
         ST    R15,COUNT           Show from first entry
         BR    R14                 Return to caller

HstNoStg MVI   MSG,102             "REVIEW" internal storage exhausted
         B     HistTerm

HstBad   MVI   MSG,130             Binder API failure rc, reason code
         L     R15,=A(REVMSGS)
         BASR  R14,R15             Fetch message text
         UNPK  MSG+24(3),BndRetcd+3(2)
         TR    MSG+24(2),HSTHEX-C'0'
         MVI   MSG+26,C' '         Show return code
         UNPK  MSG+34(9),BndRsncd(5)
         TR    MSG+34(8),HSTHEX-C'0'
         L     R14,BndParms        Point to API function code
         CLI   1(R14),1            STARTD failure?
         BE    HistTerm            Yes, no more cleanup needed
         B     HstDelWm            No, go tidy up dialog

HistGetD DS    0H                  Perform GETD call
*        IEWBIND FUNC=GETD,        Module map data
*              VERSION=?,RETCODE=BndRetcd,RSNCODE=BndRsncd,
*              WORKMOD=ModToken,CLASS=(R3),
*              AREA=BndData,CURSOR=BndCursr,COUNT=BndCount,
*              MF=(E,BndParms,COMPLETE)
         L     R15,DialgTkn        Get IEWBIND entry point
         CALL  (15),(GETD,         Function code                       +
               BndRetcd,           Return code                         +
               BndRsncd,           Reason code                         +
               ModToken,           Module token                        +
               (R3),               Class                               +
               =X'00004040',                                           +
               BndData,            Area                                +
               BndCursr,           Cursor                              +
               BndCount),          Count                               +
               VL,MF=(E,BndParms)
         CLC   BndRetCd,=F'4'      Major failure?
         BNHR  R2                  No, Return to caller
HstBadGD EQU   *
         MVI   MSG,103             API class, buffer type, reason code
         L     R15,=A(REVMSGS)
         BASR  R14,R15             Fetch message text
         MVC   MSG+14(8),BndData   Show buffer type
         MVC   MSG+7(6),2(R3)      Show class name
         UNPK  MSG+34(9),BndRsncd(5)
         TR    MSG+34(8),HSTHEX-C'0'
         B     HstDelWm            Go tidy up dialog

HstLdUsr MVC   HistUser(0),0(R15)  <<< Executed >>>

HistHex# UNPK  BndParms(9),0(5,R1)
         MVC   0(8,R15),BndParms
         TR    0(8,R15),HSTHEX-C'0'
         LA    R1,7
HistHxLp CLI   0(R15),C'0'         Leading zero?
         BNER  R14                 No, hex number now formatted
         MVI   0(R15),C' '         Yes, suppress leading zero
         LA    R15,1(,R15)         Point to next hex digit
         BCT   R1,HistHxLp
         BR    R14

         DROP  R10,R11,R13         REVHIST, @HSTWORK
         TITLE '  R E V H I S T   -   S T A T I C   A R E A  '
@HSTWKSZ DC    F'32768'            Local working storage size
HistZero DC    F'0'                Zero
DIVADDRH DC    A(REVDIV)
HSTFMTSZ DC    AL1(1),AL3($FMTLEN)
IEWBIND  DC    CL8'IEWBIND '       Binder API interface entry point
*EWBFDAT DC    CL8'IEWBFDAT'       Binder FDA interface entry point
HSTHEX   DC    C'0123456789ABCDEF' Hexadecimal digit translate table
HSTMODES DC    C'     24  31 ANY MIN RSV  64 '
HSTREUSE DC    C'    NONEREUSRENTREFR'

         DS    0F                  Ready-to-use FEL table for HISTORY
*               Symbol-Name  Flags Type Length  Columns Offset
HSTFELS  DC    CL8'IDSTRING',X'00',C'C',AL2(14),AL2(14),AL2(0)
         DC    CL8'VV.MM   ',X'00',C'C',AL2(05),AL2(05),AL2(0)
         DC    CL8'   DATE ',X'00',C'C',AL2(10),AL2(10),AL2(0)
         DC    CL8'  TIME  ',X'00',C'C',AL2(08),AL2(08),AL2(0)
         DC    CL8'  SIZE  ',X'00',C'C',AL2(08),AL2(08),AL2(0)
         DC    CL8'SECTION ',X'00',C'C',AL2(30),AL2(30),AL2(0)
HSTFELEN EQU   *-HSTFELS

         DS    0F                  Ready-to-use FEL table for MAP
*               Symbol-Name  Flags Type Length  Columns Offset
MAPFELS  DC    CL8'TYPE    ',X'00',C'C',AL2(04),AL2(04),AL2(0)
         DC    CL8'FLGS    ',X'00',C'C',AL2(02),AL2(04),AL2(0)
         DC    CL8' OFFSET ',X'00',C'C',AL2(08),AL2(08),AL2(0)
         DC    CL8'QUANTITY',X'00',C'C',AL2(08),AL2(08),AL2(0)
         DC    CL8'NAME    ',X'00',C'C',AL2(30),AL2(30),AL2(0)
MAPFELEN EQU   *-MAPFELS

         DS    0F                  Ready-to-use FEL table for ESD
*               Symbol-Name  Flags Type Length  Columns Offset
ESDFELS  DC    CL8'TYPE    ',X'00',C'C',AL2(06),AL2(06),AL2(0)
         DC    CL8'ALIGN   ',X'00',C'C',AL2(05),AL2(05),AL2(0)
         DC    CL8'STG     ',X'00',C'C',AL2(03),AL2(03),AL2(0)
         DC    CL8'REUS    ',X'00',C'C',AL2(04),AL2(04),AL2(0)
         DC    CL8'SEG     ',X'00',C'C',AL2(03),AL2(03),AL2(0)
         DC    CL8'AMD     ',X'00',C'C',AL2(03),AL2(03),AL2(0)
         DC    CL8'RMD     ',X'00',C'C',AL2(03),AL2(03),AL2(0)
         DC    CL8' OFFSET ',X'00',C'C',AL2(08),AL2(08),AL2(0)
         DC    CL8' LENGTH ',X'00',C'C',AL2(08),AL2(08),AL2(0)
         DC    CL8'NAME    ',X'00',C'C',AL2(08),AL2(08),AL2(0)
ESDFELEN EQU   *-ESDFELS

CLS_ESD  DC    H'5',CL6'B_ESD '
CLS_MAP  DC    H'5',CL6'B_MAP '
CLS_IDRL DC    H'6',CL6'B_IDRL'
CLS_IDRU DC    H'6',CL6'B_IDRU'
CLS_IDRZ DC    H'6',CL6'B_IDRZ'
CLS_IDRB DC    H'6',CL6'B_IDRB'

ISITMGDS ISITMGD DCB=0,DATATYPE=YES,MF=L
ISITMGDL EQU   *-ISITMGDS

         IEWBUFF FUNC=MAPBUF,BYTES=30000,TYPE=ESD,VERSION=1
         IEWBUFF FUNC=MAPBUF,BYTES=30000,TYPE=MAP,VERSION=5
         IEWBUFF FUNC=MAPBUF,BYTES=30000,TYPE=IDRB,VERSION=3
         IEWBUFF FUNC=MAPBUF,BYTES=30000,TYPE=IDRZ,VERSION=3
         IEWBUFF FUNC=MAPBUF,BYTES=30000,TYPE=IDRU,VERSION=3
         IEWBUFF FUNC=MAPBUF,BYTES=30000,TYPE=IDRL,VERSION=3

         LTORG

         DC    0D'0'               End of CSECT
         TITLE '  R E V H I S T   -   D Y N A M I C   A R E A  '
@HSTWORK DSECT
         DS    18F
DialgTkn DS    D                   Dialog token
ModToken DS    D                   Module token
FDAENTPT DS    A                   IEWBFDAT entry point address
BndRetcd DS    F                   Return code
BndRsncd DS    F                   Reason code
MODDCBPT DS    A                   Pointer to the open DCB
MODDEPTR DS    A                   Pointer to BLDL directory entry
BndCursr DS    A                   Cursor
BndCount DS    A                   Entry count

STARTD   DS    F                   01 - STARTDIALOG
CREATEW  DS    F                   10 - CREATEWMOD
INCLUDE  DS    F                   40 - INCLUDE
GETD     DS    F                   61 - GETDATA
DELETEW  DS    F                   15 - DELETEWMOD
ENDD     DS    F                   05 - ENDDIALOG

*  The following documents the IEWBFDAT parameter list which is no
*  longer used.  This area is now used for CALL parameter lists.
BndParms DS    0F                  IEWBFDAT parameter list
FDAEPTAD DS    A                   Pointer to module entry point addr
FDATKNAD DS    A                   Pointer to module token
FDARETAD DS    A                   Pointer to return code
FDARSNAD DS    A                   Pointer to reason code
FDAETKAD DS    A                   Pointer to EPTOKEN
FDADDNAD DS    A                   Pointer to DD name
FDAMEMAD DS    A                   Pointer to member name
FDADCBAD DS    A                   Pointer to DCB pointer
FDADEADR DS    A                   Pointer to directory entry pointer
FDACLSAD DS    A                   Pointer to class name
FDASECAD DS    A                   Pointer to section name
FDABFRAD DS    A                   Pointer to standard data buffer
FDACSRAD DS    A                   Pointer to starting position
FDACNTAD DS    A                   Pointer to data count
FDAHLDAD DS    A                   Pointer to hold flag
FDADELAD DS    A                   Pointer to delete flag
FDAHOLD  DS    C                   Hold binder resources flag
FDADEL   DS    C                   Delete binder API module flag
HistMap  EQU   X'80'               B_MAP data (use byte for local flag)

HistMem  DS    H,CL8               Member name string

HistRecd DS    0F                  Start of internal history record
HistComp DS    0CL10               Component name
HistZap  DS    0CL8                ZAP IDR data
HistUser DS    CL14                IDENTIFY string
HistVer  DS    CL2                 Component version
HistDot  DS    C                   Period
HistRel  DS    CL2                 Component release/modification
HistDate DS    CL10                Date - yyyy-mm-dd
HistTime DS    CL8                 Time - hh:mm:ss
HistSize DS    CL8                 Size
HistLen  EQU   *-HistRecd          Length of record for binder
HistSect DS    CL1024              Section name

         ORG   HistRecd
MapRecd  DS    0F                  Start of internal MAP record
MapType  DS    CL4                 Type
MapFlags DS    CL2                 Flags
MapOfst  DS    CL8                 Offset
MapSize  DS    CL8                 Quantity
MapName  DS    CL1024              Name

         ORG   HistRecd
EsdRecd  DS    0F                  Start of internal ESD record
EsdType  DS    CL6                 Type
EsdAlign DS    CL5                 Alignment
EsdStg   DS    CL3                 Read-only flag
EsdReuse DS    CL4                 Reusability
EsdSeg   DS    CL3                 Segment
EsdAmode DS    CL3                 Addressing mode
EsdRmode DS    CL3                 Residence mode
EsdOfst  DS    CL8                 Offset
EsdSize  DS    CL8                 Length
EsdName  DS    CL1024              Name

         ORG
BndData  DS    0F                  Data buffer area
         IGWCISM DSECT=YES         ISITMGD plist
         TITLE '  R E V U N I X  '
**********************************************************************
*                                                          *         *
*         HIERARCHICAL FILE DIRECTORY HANDLER              *  GP@HC  *
*                                                          * 10/2000 *
**********************************************************************
*                                                                    *
* Registers on entry: R9 -> @DATA                                    *
*                     R13-> Save area                                *
*                     R14-> Return address                           *
*                     R15-> REVUNIX                                  *
*                                                                    *
* During processing:  R13-> @HFSDYN  (local GETMAINed area)          *
*                                                                    *
* Return codes:       R15 = 0  Processing complete                   *
*                                                                    *
**********************************************************************

REVUNIX  CSECT
REVUNIX  AMODE 31
         B     @UNIX-*(,R15)
@UNIXLBL EQU   *+1,8
         DC    AL1(7),CL11'REVUNIX'
@HFSSIZE DC    A($HFSDYNL)
@UNIX    STM   R14,R12,12(R13)     Save registers
         LR    R11,R15             Base registers
         LA    R15,1
         LA    R10,4095(R15,R11)
         USING (REVUNIX,HFSFRMAT),R11,R10
         L     R0,@HFSSIZE         Get dynamic area size
         MVI   GETMNTRC,93         Track GETMAIN in case of failure
         GETMAIN RU,LV=(0),LOC=(31,64),SP=1
         ST    R1,8(,R13)          Chain save areas
         ST    R13,4(,R1)
         LR    R13,R1              Point to dynamic area
         USING @HFSDYN,R13

         OI    $UCBAD,$HFSIO       Flag processing UNIX files
*        CALL  BPX1GEU,            Get effective user id
         L     R15,FLCCVT          CVT
         L     R15,CVTCSRT-CVT(,R15) CSRTABLE
         L     R15,24(,R15)        CSR slot
         L     R15,#BPX1GEU(,R15)  Address of the service
         CALL  (15),(EUIDORIG),    Get effective user id               +
               VL,MF=(E,HFSPLIST)
         MVC   EUIDCRNT,EUIDORIG   Update current effective UID
         LR    R1,R13              Point to GETMAINed area
         A     R1,@HFSSIZE         Point past it
         LA    R0,1024             Take a punt
         SR    R1,R0
         ST    R1,MAXENTAD         Save highest usable address
         XC    SELENTNM,SELENTNM   Reset entry name to search for
         XC    SELENTNM+2(256),SELENTNM+2
         L     R1,REVCBUF          Point to the command buffer
         LH    R14,2(,R1)          Get parsed character count
         LA    R14,4(,R14)         Count length fields
         LH    R15,0(,R1)          Get command buffer length
         SR    R15,R14             Get length of specified path name
         ALR   R14,R1              Point to specified path name
         CLI   0(R14),QUOTE        Quoted directory name?
         BNE   HFSETDIR            No, proceed
         LA    R14,1(,R14)         Yes, point past the quote
         BCTR  R15,0               Adjust the length
         BCTR  R15,0               Also discount the trailing quote
         LA    R1,0(R15,R14)       Point to the trailing quote
         CLI   0(R1),QUOTE         Was it really a quote?
         BE    HFSETDIR            Yes, proceed
         LA    R15,1(,R15)         No, so better include it
HFSETDIR ST    R15,$DIRNMLN        Save path name length
         ICM   R15,8,HFBLANKS      Set pad character
         LA    R6,$DIRNAME         Set target address
         LA    R7,L'$DIRNAME       Set target length
         MVCL  R6,R14              Copy initial path name
DOHFSSEL L     R1,$DIRNMLN         Get directory name length
         LA    R1,$DIRNAME(R1)     Point past directory name
HFBLNKLP CLI   0(R1),C' '          Trialing blank?
         BNE   HFBLNKOK            No
         BCT   R1,HFBLNKLP         Yes, back up one
HFBLNKOK CLI   0(R1),C'/'          Trailing slash supplied?
         BNE   HFGOTPTH            No
         MVI   0(R1),C' '          Yes, erase it
         BCTR  R1,0                Point to last non-blank
HFGOTPTH LA    R0,$DIRNAME
         LA    R1,1(,R1)           Point to first trailing blank
         SR    R1,R0               Get the length of non-blanks
         BNP   SET_ROOT            Root directory was requested
         ST    R1,$PATHLEN         Save path length
         LA    R3,HFSENTS          Point to first entry
         ST    R3,LSTENTAD         Say it is last entry
*        CALL  BPX1STA,            Get file status
         L     R15,FLCCVT          CVT
         L     R15,CVTCSRT-CVT(,R15) CSRTABLE
         L     R15,24(,R15)        CSR slot
         L     R15,#BPX1STA(,R15)  Address of the service
         CALL  (15),               Get file status                     +
               ($PATHLEN,$DIRNAME,HFSTATLN,STAT,                       +
               HFSRETVL,HFSRETCD,HFSRSNCD),                            +
               VL,MF=(E,HFSPLIST)
         L     R1,$PATHLEN         Get path name length
         TM    HFSRETVL,X'80'      File status data returned?
         BO    ADDSLASH            No, let directory display handle it
         CLI   ST_MODE,FT_DIR      Is selected entry a directory?
         BE    ADDSLASH            Yes, show its contents
         LA    R0,$DIRNAME         Point to the path name
         LR    R3,R1               Get path name length
         AR    R3,R0               Point past the path name
HFSLSHLP CLI   0(R3),C'/'          Back to end of directory name?
         BE    *+8                 Yes, leave loop
         BCT   R3,HFSLSHLP         No, back up another one
         LA    R3,1(,R3)           Point past directory name
         SR    R3,R0               Get directory name length
         ST    R3,$DIRNMLN         Save it
         LA    R0,$DIRNAME(R3)     Point to file name
         SR    R1,R3               Get file name length
         MVC   DOUBLE,ST_AUDITID+1 Copy volume serial number
         MVC   UFILESIZ,ST_SIZE_L  Make the file size accessible
         MVC   UREADCNT,ST_BLKSIZE Set byte count per read at 4096
         B     HFSOPNIT            Go REVIEW the file
ADDSLASH LA    R3,$DIRNAME(R1)     Point past name
         MVI   0(R3),C'/'          Add the trailing slash
         LA    R1,1(,R1)           Increment name length
HFDIRLEN ST    R1,$DIRNMLN         Set actual directory name length
HFGOTDIR BAS   R14,HFSHOWNM        Put directory name into heading
HREFRESH L     R7,=A(READHFS)      Point to directory processor
         BR    R7                  Process directory information
SET_ROOT MVI   $DIRNAME,C'/'       Set root directory name
         LA    R1,1                Get root directory name length
         B     HFDIRLEN            Show root directory contents

TOPENTRY OI    STATUS,STPODIR      Flag directory list mode
         TM    STATUS4,$4ATTN      Attention interrupt?
         BO    FINDENT             Yes, don't perform sort
         TM    STATUS3,$3DATE
         BO    SORTMDDT
         TM    STATUS3,$3SIZE
         BO    SORTBYTE
         TM    STATUS3,$3TTR
         BO    SORTCRDT
         TM    STATUS3,$3USER
         BO    SORTUID
         TM    STATUS3,$3SSI
         BO    SORTACDT
         B     SORTENTN            Handle out-of-order mount points
FINDENT  LA    R3,HFSENTS          Point to first entry
         USING @UNIXENT,R3
         TM    STATUS7,$7SAVE      SPF edited and saved a file?
         BZ    TRYNOENT            No
         MVI   MSG,96              File saved
         NI    STATUS7,255-$7SAVE  Reset edited and saved flag
TRYNOENT OC    SELENTNM,SELENTNM   Non-zero file name to locate?
         BZ    THISENT             No, go to top
TRYENTNM LA    R0,SELENTNM+2       Point to requested name
         LH    R1,SELENTNM         Get length of requested name
         LA    R14,UENAME          Point to entry's name
         LH    R15,UENMLN          Get length of entry's name
         ICM   R15,8,HFBLANKS      Set pad character
         CLCL  R0,R14              Up to required file?
         BE    THISENT             Yes, found it
         BH    NEXTENT             No, no there yet
         TM    STATUS3,$3SORT      Entries in collating sequence?
         BZ    PREVENT             Yes, passed it, so backup one
NEXTENT  C     R3,LSTENTAD         No, reached end of entries?
         BE    NOTTHERE            Yes, stop scanning
         AH    R3,UELEN            Point to next entry
         B     TRYENTNM
NOTTHERE TM    STATUS3,$3SORT      Entries in collating sequence?
         BZ    THISENT             No message needed
         TM    STATUS3,$3USER      Entries in owner name sequence?
         BO    HFLOCUID            Yes
         MVI   MSG,76              Exact name not found
SAMEENTS L     R3,TOPENTAD         Restore entry pointer
         B     THISENT             Reshow without movement
HFLOCUID OC    SELENTNM+2(8),HFBLANKS  Fold to upper case
         LA    R3,HFSENTS          Point to first entry
HFLOCULP C     R3,LSTENTAD         Reached last entry?
         BNL   THISENT             Yes, show it
         CLC   UEOWNER,SELENTNM+2  Up to required owner name?
         BE    THISENT             Yes
         BH    PREVENT             Yes, past it so back up one
         AH    R3,0(,R3)           No, point to next entry
         B     HFLOCULP
PREVENT  LA    R2,HFSENTS          Get first entry address
         CR    R2,R3               At first entry?
         BE    THISENT             Yes, can't go back one
         LR    R2,R3               No, point to this entry
         BCTR  R2,0                Point to last halfword
         BCTR  R2,0                         of previous entry
         SH    R3,0(,R2)           Point to previous entry
THISENT  XC    SELENTNM,SELENTNM   Clear file name to be located
         XC    SELENTNM+2(256),SELENTNM+2
         NI    STATUS4,255-$4REFR  Reset refresh flag
         TM    @HFSDYN,$HFSEND     ENDed to parent?
         BNO   HFSHEAD             No
         ST    R3,CURENTAD         Yes, move cursor to it
         NI    @HFSDYN,255-$HFSEND Reset flag
         CLC   ISPFPAGE,ENTRYCNT   Can all entries be shown at once?
         BNH   HFSHEAD             No, do not scroll
         LA    R3,HFSENTS          Yes, point to first entry
HFSHEAD  ST    R3,TOPENTAD         Save top file entry address
         MVI   HDCOLOR,X'05'       Clear screen to turquoise blanks
         L     R15,=A(REVHEAD)     Point to heading routine
         BASR  R14,R15             Initialise first two screen lines
         L     R2,SCREENBF         Point to the primary buffer
         A     R2,SCRNCOLS         Point to the second primary line
         LR    R14,R2
         LA    R0,12
         SLR   R14,R0              Back up twelve bytes
         LA    R1,1                Count **END**
         A     R1,ENTRYCNT         Get list entry count in binary
         CVD   R1,DOUBLE           Get list entry count in decimal
         LA    R1,11(,R14)         Point to last digit
         MVC   4(8,R14),ED7DASH    Load edit mask
         EDMK  4(8,R14),DOUBLE+4   Show up to 9999999 entries correctly
         LR    R14,R1
         SLR   R14,R0              Back up twelve bytes before number
         L     R1,UESEQNO          Get current row number in binary
         CVD   R1,DOUBLE           Get current row number in decimal
         LA    R1,7(,R14)          Point to last digit
         MVC   8(4,R14),=C' of '
         MVC   0(8,R14),ED7DASH    Load edit mask
         EDMK  0(8,R14),DOUBLE+4   Show up to row 9999999 correctly
         SLR   R1,R0               Back up twelve bytes before number
         MVC   7(5,R1),=C' Row '
         A     R2,SCRNCOLS         Point to the third primary line
         LR    R1,R2               Point to the third primary line
         A     R1,SCREENSZ         Point to the third shadow line
         MVI   0(R2),FLDOUTHI      Column headings in high intensity
         MVI   0(R1),X'06'         Column headings in yellow
         MVC   1(255,R1),0(R1)     Spread colour along the whole line
         MVI   9(R1),X'05'         (Link-Symbol) label in turquoise
         MVC   10(12,R1),9(R1)
         MVC   4(18,R2),HFSNMLBL   Label the file name column
         A     R2,SCRNCOLS         Point to the fourth screen line
         LR    R14,R2              Label the other columns
         LA    R0,HFSUBHDL
         SLR   R14,R0
         MVC   0(HFSUBHDL,R14),HFSUBHDG
         CLI   SCRNCOLS+3,95       Screen wider than 94 columns?
         BL    HFSBHDOK            No
         LA    R0,L'HFSUBHDW       Yes
         SLR   R14,R0
         MVC   0(L'HFSUBHDW,R14),HFSUBHDW
HFSBHDOK L     R5,SCRNLNES         Get number of lines on screen
         SH    R5,=H'3'            Less three lines for headings
         XC    SELENTNM,SELENTNM   Clear file name in readiness
         XC    SELENTNM+2(256),SELENTNM+2
         SR    R0,R0               Clear for insert characters
         L     R7,=A(HFSFRMAT)     Point to line formatting routine
LODENTNM CLC   0(4,R3),LASTENT     End of file list?
         BNER  R7                  No, format a file directory entry
         DROP  R3                  @UNIXENT
         MVI   0(R2),FLDOUTHI      High intensity
         LR    R0,R2               Point to primary buffer line
         S     R0,SCREENBF         Get offset into screen
         L     R1,SCREENSZ         Get size of screen
         SR    R1,R0               Get size of the rest of screen
         A     R0,SHADOWBF         Point to shadow buffer line
         LA    R15,X'06'           Get internal code for yellow
         SLL   R15,24              Set as pad and zero source length
         MVCL  R0,R14              Set rest of screen to yellow
         MVC   3(7,R2),EODIRTXT    Indicate end of directory entries
         LA    R0,80
         LR    R6,R2               Copy line pointer
         A     R6,SCRNCOLS         Point to next line
         SLR   R6,R0               Point back to current format area
         LM    R14,R15,HFSTOTSZ    Get file size
         SRDL  R14,10              Divide by 1024
         SLDL  R14,10              Multiply by 1024
         CL    R15,HFSTOTSZ+4      Is size a multiple of 1024?
         BE    HFSTOTLK            Yes, go show kilobytes
         L     R15,HFSTOTSZ+4      No, reload exact byte count
         LA    R15,0(,R15)         Clear sign bit
         CVD   R15,DOUBLE
         TM    HFSTOTSZ+4,X'80'    File larger than 2GB?
         BZ    HFSTOT2G            No
         AP    DOUBLE,HFS2GIG      Yes, correct the count
HFSTOT2G MVC   49(12,R6),HFSED11   Load edit mask
         ED    49(12,R6),DOUBLE+2  Show byte count
         B     HFSTOTOK
HFSTOTLK SRDL  R14,10              Divide by 1024 (again)
         CVD   R15,DOUBLE
         MVC   48(12,R6),HFSED11   Load edit mask
         ED    48(12,R6),DOUBLE+2  Show byte count
         MVI   60(R6),C'K'         Denote kilobytes
HFSTOTOK DS    0H                  Done **END** statistics
DSPLYHFS BAS   R14,HFSHOWNM        Put directory name into heading
         MVC   COMPON,@UNIXLBL     Flag component for help
         MVC   REVHELP,REVHU00     Flag help panel to ISPF
         L     R15,=A(REVCOMM)     No parameter list passed
         BASR  R14,R15             Display screen and receive input
         MVC   KOUNT,TOPENTAD      Save pre-scroll top entry address

*  The 3270 data stream no longer has to be interpreted here because
*  REVCOMM will supply an 'S' selection code implied by the cursor
*  location if appropriate, and will also strip off any non-primary
*  input fields.  Further, primary input has had any PFK command
*  prefixing and command string parsing performed by REVCOMM.
*  Implicit and explicit selection codes are stored directly in REVBUF.
         TM    OPD0+6,PRESENT      Any subcommand requested?
         BNO   HFSELCHK            No, go check for selection codes
         L     R14,OPD0            Yes, point to it
         LH    R15,OPD0+4          Get its length
         CLI   0(R14),C'/'         New path specification?
         BE    HFSETDIR            Yes, go directly to it
         LR    R1,R14              No, point to the primary command
         CLI   0(R1),C'L'          Possible locate request?
         BE    HFSCASOK            Yes, do not fiddle with operand case
         CLI   0(R1),C'/'          Jump-to-path request?
         BE    HFSCASOK            Yes, do not fiddle with operand case
         CLI   0(R1),C'B'          Possible browse request?
         BE    HFSCASOK            Yes, do not fiddle with operand case
         CLI   0(R1),C'E'          Possible browse request?
         BE    HFSCASOK            Yes, do not fiddle with operand case
         CLI   0(R1),C'S'          Possible select request?
         BNE   HFSKAPS             No, upper case it
         CLI   1(R1),C'O'          Possible sort request?
         BNE   HFSCASOK            No, must be select so leave case
HFSKAPS  L     R5,=A(KAPS)         Point to translate table
         TR    CMDAREA,0(R5)       Upper case all primary input
HFSCASOK LR    R5,R15              Get subcommand length code plus 1
         L     R15,=A(HFSCMDTB)    Point to subcommand table
         LA    R0,7
         CLR   R5,R0               Length larger than maximum?
         BNH   HFSCMDLP            No
         LR    R5,R0               Yes, reduce to maximum
HFSCMDLP EX    R5,HFCMDTST         Found the subcommand?
         BL    HFSCMDBD            No, invalid subcommand
         BE    8(,R15)             Yes, perform it
         LA    R15,12(,R15)        Not yet, point to next entry
         B     HFSCMDLP            Continue subcommand table scan
HFCMDTST CLC   0(0,R1),0(R15)      <<< Executed >>>
HFSCMDBD MVI   MSG,20              Invalid command
         B     SAMEENTS            Go show the message

HFSMISOP MVI   MSG,35              Missing operand
         B     DSPLYHFS            Go display this message

HFSLOC   BAS   R14,GTENTNAM        Extract the specified entry name
         B     FINDENT             Go locate entry

HFSEND   L     R1,$DIRNMLN         Get current directory name length
         LA    R3,$DIRNAME(R1)     Point past directory name
HFSENDLP BCTR  R3,0                Back up a byte
         CLI   0(R3),C'/'          Reached back to a higher level?
         BNE   HFSENDNX            No, clear the character
         C     R1,$DIRNMLN         Trailing slash of original name?
         BNE   HFSENDED            No, have gone back a level
         MVI   0(R3),C' '          Erase trailing slash
         BCTR  R1,0
         LTR   R1,R1               Cleared all levels?
         BNP   HFSEXIT             Yes, so exit
         ST    R1,$DIRNMLN         Pretend there was no trailing slash
         B     HFSENDLP            Continue clearing lowest level
HFSENDNX BCT   R1,HFSENDLP         Continue clearing lowest level
         B     HFSEXIT             Cleared all levels so exit
GETNDLVL MVC   SELENTNM+2(0),1(R3) <<< Executed >>>
CLRNDLVL XC    1(0,R3),1(R3)       <<< Executed >>>
HFSENDED L     R14,$DIRNMLN        Get previous name length
         ST    R1,$DIRNMLN         Save new directory name length
         SR    R14,R1              Get cleared level name length
         STH   R14,SELENTNM        Save this length
         MVI   SELENTNM+2,C' '     Clear residual data
         MVC   SELENTNM+3(255),SELENTNM+2
         BCTR  R14,0               Decrement for execute
         EX    R14,GETNDLVL        Copy cleared level name for locate
         EX    R14,CLRNDLVL        Clear previous lowest level name
         OI    @HFSDYN,$HFSEND     Flag ENDed to parent directory
         B     HFGOTDIR            Go show higher level directory

HFSTOP   LA    R3,HFSENTS          Point to first entry
         ST    R3,TOPENTAD         Save new top entry pointer
         B     HFSELCHK            Check for selection codes

HFSBOTOM L     R3,LSTENTAD         Point to **END**
         AH    R3,0(,R3)           Point past it
         BCTR  R3,0
         BCTR  R3,0                Point to **END**'s length indicator
         L     R1,ISPFPAGE         Get number of screen data lines
         B     HFSCLIMB                and scroll up one page

HFSUPCMD L     R15,=A(DIRSCROL)    Point to routine entry point
         BASR  R14,R15             Determine scroll amount
         LTR   R15,R15             Test return code
         BM    HFSBADOP            Invalid operand
         BP    HFSTOP              Scroll amount is maximum
         L     R3,TOPENTAD         Point to current top entry
         BCTR  R3,0                Point to length of previous entry
         BCTR  R3,0
         LTR   R1,R1               Anything to scroll?
         BNP   FNDUPENT            No
HFSCLIMB LA    R2,HFSENTS          Point to first entry
UPONEENT CR    R3,R2               Pointing to before first entry?
         BL    FNDUPENT            Yes, use first entry
         SH    R3,0(,R3)           No, back up one entry
         BCT   R1,UPONEENT
FNDUPENT LA    R3,2(,R3)           Point to start of entry
         ST    R3,TOPENTAD         Save new top entry pointer
         B     HFSELCHK            Check for selection codes

HFSDNCMD L     R15,=A(DIRSCROL)    Point to routine entry point
         BASR  R14,R15             Determine scroll amount
         LTR   R15,R15             Test return code
         BM    HFSBADOP            Invalid operand
         BP    HFSBOTOM            Scroll amount is maximum
         L     R3,TOPENTAD         Point to current top entry
         LTR   R1,R1               Anything to scroll?
         BNP   HFSDNDON            No
DOWN1ENT C     R3,LSTENTAD         Pointing to last entry?
         BNL   HFSDNDON            Yes, use last entry
         AH    R3,0(,R3)           No, point to next entry
         BCT   R1,DOWN1ENT
HFSDNDON ST    R3,TOPENTAD         Save new top entry pointer
         B     HFSELCHK            Check for selection codes

HFSCAN   NI    STATUS,255-STPROF   Turn off profile rewrite flag
HFSEXIT  L     R0,@HFSSIZE         Get dynamic area size
         LR    R1,R13              Get dynamic area address
         L     R13,4(,R13)         Point to caller's save area
         FREEMAIN RU,LV=(0),A=(1),SP=1
         LM    R14,R12,12(R13)     Restore registers
         SR    R15,R15
         STH   R15,RC              Overwrite previous non-zero rc
         BR    R14                 Return

HFSSORT  TM    OPD1+6,PRESENT      Any operand specified?
         BNO   HFSMISOP            No, so sort request type unknown
         OI    @HFSDYN,$HFSORT     Flag explicit SORT command
         L     R1,OPD1             Yes, point to it
         CLC   =C'CH',0(R1)        Changed?
         BE    SORTMDDT            Yes
         CLC   =C'CR',0(R1)        Created?
         BE    SORTCRDT            Yes
         CLI   0(R1),C'A'          Accessed?
         BE    SORTACDT            Yes
         CLI   0(R1),C'M'          Modified?
         BE    SORTMDDT            Yes
         CLI   0(R1),C'I'          Id?
         BE    SORTUID             Yes
         CLI   0(R1),C'N'          Name?
         BE    SORTENTN            Yes
         CLI   0(R1),C'O'          Owner?
         BE    SORTUID             Yes
         CLI   0(R1),C'S'          Size?
         BE    SORTBYTE            Yes
         CLI   0(R1),C'U'          Userid?
         BE    SORTUID             Yes
         NI    @HFSDYN,255-$HFSORT Clear SORT request flag
HFSBADOP MVI   MSG,34              Invalid operand
         B     DSPLYHFS            Go display this message

SORTENTN MVC   DOUBLE(4),LSTENTAD  Load first bubble pass limit
         LA    R2,HFSENTS          Point to first entry
         C     R2,DOUBLE           Any entries in this directory?
         BE    HFNOENTS            No
         ST    R2,DOUBLE+4         Save address of first entry to sort
BUBLENTN MVI   STATUS3,0           Reset sort swap flag
         MVC   OPEND,DOUBLE+4      Update start of bubble pass limit
         L     R2,OPEND            Point to first entry to sort
         MVC   DOUBLE+4(4),DOUBLE  Update end of bubble pass limit
NEXTENTN LR    R1,R2
         AH    R2,0(,R1)           Point to second entry for compare
         C     R2,DOUBLE+4         Reached end of pass?
         BE    FINALENT            Yes, check for final pass
         LA    R4,UENAME-@UNIXENT(,R1)
         LA    R6,UENAME-@UNIXENT(,R2)
         LH    R5,UENMLN-@UNIXENT(,R1)
         LH    R7,UENMLN-@UNIXENT(,R2)
         ICM   R7,8,HFBLANKS       Set pad character
         CLCL  R4,R6               Compare entry names
         BNH   NEXTENTN            These two are in order
         BAS   R14,SWAPENTS        Out of order so bubble down one
         B     NEXTENTN            Process next entry
FINALENT TM    STATUS3,$3BUBL      Any entries bubbled in this pass?
         BNO   EXITENTN            No, exit from sort by name
         MVI   STATUS3,0           Yes, reset sort swap flag
         L     R1,DOUBLE           Point past entries to sort
         BCTR  R1,0
         BCTR  R1,0                Point to trailing length field
         LA    R2,OPEND            Point to first entry to sort
         CR    R1,R2               Backed up too far?
         BL    EXITENTN            Yes, must be all sorted now
         SH    R1,0(,R1)           Point to before last unsorted entry
BACKENTN LR    R2,R1
         SH    R1,0(,R2)           Point to previous entry for compare
         LA    R4,UENAME-@UNIXENT+2(,R1)
         LA    R6,UENAME-@UNIXENT+2(,R2)
         LH    R5,UENMLN-@UNIXENT+2(,R1)
         LH    R7,UENMLN-@UNIXENT+2(,R2)
         ICM   R7,8,HFBLANKS       Set pad character
         CLCL  R4,R6               Compare entry names
         BNH   BAKUPENT            These two are in order
         BAS   R14,SWPBKENT        Out of order so bubble up one
BAKUPENT C     R1,OPEND            Back to start of entries to sort?
         BNL   BACKENTN            Process previous entry
         TM    STATUS3,$3BUBL      Any entries bubbled in this pass?
         BO    BUBLENTN            Yes, do another pass
EXITENTN B     HFSSORTX            Go load sorted message

SORTMDDT LA    R0,UEMODDT-@UNIXENT Get sort field offset
         LA    R15,$3DATE          Get sort flag type
         SLL   R15,8               Clear execute length code byte
         LA    R15,L'UEMODDT-1(,R15) Get sort field length
         ICM   R15,8,HFSHEX        Flag descending sort request
         B     SORTHFS

SORTBYTE LA    R0,UESIZE-@UNIXENT  Get sort field offset
         LA    R15,$3SIZE          Get sort flag type
         SLL   R15,8               Clear execute length code byte
         LA    R15,L'UESIZE-1(,R15) Get sort field length
         ICM   R15,8,HFSHEX        Flag descending sort request
         B     SORTHFS

SORTCRDT LA    R0,UECREDT-@UNIXENT Get sort field offset
         LA    R15,$3TTR           Get sort flag type
         SLL   R15,8               Clear execute length code byte
         LA    R15,L'UECREDT-1(,R15) Get sort field length
         ICM   R15,8,HFSHEX        Flag descending sort request
         B     SORTHFS

SORTUID  LA    R0,UEOWNER-@UNIXENT Get sort field offset
         LA    R15,$3USER          Get sort flag type
         SLL   R15,8               Clear execute length code byte
         LA    R15,L'UEOWNER-1(,R15) Get sort field length
         B     SORTHFS

SORTACDT LA    R0,UEACCDT-@UNIXENT Get sort field offset
         LA    R15,$3SSI           Get sort flag type
         SLL   R15,8               Clear execute length code byte
         LA    R15,L'UEACCDT-1(,R15) Get sort field length
         ICM   R15,8,HFSHEX        Flag descending sort request

SORTHFS  MVC   DOUBLE(4),LSTENTAD  Load first bubble pass limit
         LA    R2,HFSENTS          Point to first entry
         C     R2,DOUBLE           Any entries in this directory?
         BE    HFNOENTS            No
         ST    R2,DOUBLE+4         Save address of first entry to sort
BUBLHFS  STCM  R15,2,STATUS3       Reset sort swap flag
         MVC   OPEND,DOUBLE+4      Update start of bubble pass limit
         L     R2,OPEND            Point to first entry to sort
         MVC   DOUBLE+4(4),DOUBLE  Update end of bubble pass limit
NEXTHFS  LR    R1,R2
         AH    R2,0(,R1)           Point to second entry for compare
         C     R2,DOUBLE+4         Reached end of pass?
         BE    FINALHFS            Yes, check for final pass
         LR    R3,R1               Point to first entry
         LR    R4,R2               Point to second entry
         AR    R3,R0               Point to first sort field
         AR    R4,R0               Point to second sort field
         LTR   R15,R15             Sorting into descending order?
         BM    DESCHFS             Yes
         EX    R15,COMPHFS         No, compare sort fields
         BNH   NEXTHFS             These two are in order
         BAS   R14,SWAPENTS        Out of order so bubble down one
         B     NEXTHFS             Process next entry
DESCHFS  EX    R15,COMPHFS         Compare sort fields
         BNL   NEXTHFS             These two are in order
         BAS   R14,SWAPENTS        Out of order so bubble down one
         B     NEXTHFS             Process next entry
COMPHFS  CLC   0(0,R3),0(R4)       <<< Executed >>>
COMPHFSB CLC   2(0,R3),2(R4)       <<< Executed >>>
FINALHFS TM    STATUS3,$3BUBL      Any entries bubbled in this pass?
         BNO   HFSSORTX            No, exit from HFS entry sort
         STCM  R15,2,STATUS3       Yes, reset sort swap flag
         L     R1,DOUBLE           Point past entries to sort
         BCTR  R1,0
         BCTR  R1,0                Point to trailing length field
         LA    R2,OPEND            Point to first entry to sort
         CR    R1,R2               Backed up too far?
         BL    HFSSORTX            Yes, must be all sorted now
         SH    R1,0(,R1)           Point to before last unsorted entry
BACKHFS  LR    R2,R1
         SH    R1,0(,R2)           Point to previous entry for compare
         LR    R3,R1               Point to first entry
         LR    R4,R2               Point to second entry
         AR    R3,R0               Point to first sort field
         AR    R4,R0               Point to second sort field
         LTR   R15,R15             Sorting into descending order?
         BM    BDESCHFS            Yes
         EX    R15,COMPHFSB        No, compare sort fields
         BNH   BAKUPHFS            These two are in order
         BAS   R14,SWPBKENT        Out of order so bubble up one
         B     BAKUPHFS            Done ascending sort test
BDESCHFS EX    R15,COMPHFSB        Compare sort fields
         BNL   BAKUPHFS            These two are in order
         BAS   R14,SWPBKENT        Out of order so bubble up one
BAKUPHFS C     R1,OPEND            Back to start of entries to sort?
         BNL   BACKHFS             Process previous entry
         TM    STATUS3,$3BUBL      Any entries bubbled in this pass?
         BO    BUBLHFS             Yes, do another pass
HFSSORTX TM    @HFSDYN,$HFSORT     Explicit SORT command?
         BNO   FINDENT             No, skip sorted message display
         NI    @HFSDYN,255-$HFSORT Yes, clear SORT request flag
         TM    STATUS3,$3SSI       Sort by access timestamp?
         BO    STDNACDT            Yes, show correct message
         TM    STATUS3,$3USER      Sort by UID?
         BO    STDNUID             Yes, show correct message
         TM    STATUS3,$3TTR       Sort by creation timestamp?
         BO    STDNCRDT            Yes, show correct message
         TM    STATUS3,$3SIZE      Sort by size?
         BO    STDNBYTE            Yes, show correct message
         TM    STATUS3,$3DATE      Sort by modification timestamp?
         BO    STDNMDDT            Yes, show correct message
         MVI   MSG,62              Sorted by name
         B     FINDENT
STDNACDT MVI   MSG,67              Sorted by access date/time
         B     FINDENT
STDNUID  MVI   MSG,68              Sorted by owner name
         B     FINDENT
STDNCRDT MVI   MSG,69              Sorted by creation date/time
         B     FINDENT
STDNBYTE MVI   MSG,63              Sorted by size
         B     FINDENT
STDNMDDT MVI   MSG,61              Sorted by modification date/time
         B     FINDENT

HFNOENTS MVI   MSG,74              No directory entries to process
         B     SAMEENTS            Go show the message

SWAPENTS TM    STATUS4,$4ATTN      Attention interrupt?
         BO    HSRTATTN            Yes, terminate sort
         LH    R7,0(,R1)           Get the length of the first entry
         LA    R6,HFSRDBUF         Point to the save area
         LR    R5,R7               Copy length
         LR    R4,R1               Point to first entry
         MVCL  R6,R4               Save first entry
         LR    R4,R2               Point to the second entry
         LH    R5,0(,R2)           Get the length of the second entry
         LR    R6,R1               Point to the first entry
         LR    R7,R5               Copy length
         MVCL  R6,R4               Overlay first entry with second
         LH    R7,HFSRDBUF         Get length of saved entry
         LA    R4,HFSRDBUF         Point to saved entry
         LR    R5,R7               Copy length
         MVCL  R6,R4               Copy back saved entry
         LR    R2,R1
         AH    R2,0(,R1)           Point to new location of first
         L     R6,4(,R1)           Swap sequence numbers
         MVC   4(4,R1),4(R2)
         ST    R6,4(,R2)
         OI    STATUS3,$3BUBL      Indicate movement in this pass
         ST    R2,DOUBLE           Update end of bubble pass limit
         BR    R14                 Return to bubble sort mainline
SWPBKENT TM    STATUS4,$4ATTN      Attention interrupt?
         BO    HSRTATTN            Yes, terminate sort
         LH    R7,2(,R1)           Get the length of the first entry
         LA    R6,HFSRDBUF         Point to the save area
         LR    R5,R7               Copy length
         LA    R4,2(,R1)           Point to first entry
         MVCL  R6,R4               Save first entry
         LA    R4,2(,R2)           Point to the second entry
         LH    R5,2(,R2)           Get the length of the second entry
         LA    R6,2(,R1)           Point to the first entry
         LR    R7,R5               Copy length
         MVCL  R6,R4               Overlay first entry with second
         LH    R7,HFSRDBUF         Get length of saved entry
         LA    R4,HFSRDBUF         Point to saved entry
         LR    R5,R7               Copy length
         MVCL  R6,R4               Copy back saved entry
         LR    R2,R1
         AH    R2,2(,R1)           Point to new location of first
         L     R6,6(,R1)           Swap sequence numbers
         MVC   6(4,R1),6(R2)
         ST    R6,6(,R2)
         OI    STATUS3,$3BUBL      Indicate movement in this pass
         LA    R2,2(,R2)           Point to actual start of 2nd entry
         ST    R2,DOUBLE+4         Update start of bubble pass limit
         BR    R14                 Return to bubble sort mainline
HSRTATTN MVI   MSG,59              Interrupt - directory sort ended
         B     HFSTOP              Attention hit so stop sorting

HFSHOWNM L     R2,SCREENBF         Point to primary/text screen buffer
         MVI   1(R2),C'-'          Re-initialize heading message text
         MVC   2(53,R2),1(R2)      Set message area to dashes
         L     R15,$DIRNMLN        Get directory name length
         LA    R0,54               Get maximum length
         CR    R15,R0              Name too long to fit?
         BNH   EXDIRNAM            No
         LR    R15,R0              Yes, reduce to maximum
EXDIRNAM EX    R15,GTDIRNAM
         TR    1(54,R2),PERIODS    Handle bad code points in name
         LR    R1,R2               Point to primary/text screen buffer
         AR    R2,R15              Point past name
         MVI   1(R2),C' '          Supply blank after end of name
         MVC   MSGDSN,1(R1)        Save text for REVCOMM
         MVI   $DSNAME+2,C' '      Clear residual data
         MVC   $DSNAME+3(43),$DSNAME+2
         LA    R0,44               Get maximum dsname length
         CR    R15,R0              Name too long to fit?
         BNH   EXDIRDSN            No
         LR    R15,R0              Yes, reduce to maximum
EXDIRDSN STH   R15,$DSNAME         Load something for session swap list
         BCTR  R15,0               Decrement for execute
         EX    R15,GTDIRDSN        Load "data set name"
         MVC   $DDNAME,HFDDNAME    Supply an indicative file name
         MVC   $VOLSER,HFDDNAME+1  Supply an indicative volume serial
         BR    R14                 Return to caller
GTDIRNAM MVC   1(0,R2),$DIRNAME    <<< Executed >>>
GTDIRDSN MVC   $DSNAME+2(0),MSGDSN <<< Executed >>>

GTENTNAM TM    OPD1+6,PRESENT      Any operand specified?
         BNO   HFSMISOP            No, required member hint missing
         L     R0,OPD1             Point to start of text
         LH    R1,OPD1+4           Get text length
         LA    R6,SELENTNM+2       Get target address
         LA    R7,256              Get target length
         STH   R1,SELENTNM         Save entry name length
         ICM   R1,8,HFBLANKS       Set pad character
         MVCL  R6,R0               Copy primary input string
         BR    R14                 Return to caller

HFSELCHK TM    STATUS4,$4REFR      Screen contents overwritten?
         BO    SAMEENTS            Yes, no selection codes
         L     R0,SCRNCOLS         Get screen width
         LR    R1,R0               Copy it
         AR    R1,R0               Double it
         AR    R1,R0               Triple it
         A     R1,SCREENBF         Point to first displayed member
         LA    R1,1(,R1)           Point to actual selection code byte
         L     R4,KOUNT            Point to pre-scroll top entry
         B     HFSEL1ST
         USING @UNIXENT,R4
HFSSELLP A     R1,SCRNCOLS         Point to next line
         C     R1,SHADOWBF         Gone past primary screen buffer?
         BNL   SAMEENTS            Yes
         AH    R4,UELEN            Point to next internal entry
HFSEL1ST C     R4,LSTENTAD         Reached end of directory?
         BNL   SAMEENTS            Yes
         OI    0(R1),C' '          Fold selection code to upper case
         CLI   0(R1),C' '          Blank code?
         BE    HFSSELLP            Yes
         CLI   0(R1),C'.'          No-op code?
         BE    HFSSELLP            Yes
         CLI   0(R1),C'T'          Entry tag selection?
         BE    TAGFILE             Yes, go flag entry for later
         CLI   0(R1),C'R'          Entry tag selection reset?
         BE    RESFILE             Yes, go unflag entry
         CLI   0(R1),C'B'          SPF browse selection?
         BE    HISPFCHK            Yes, check validity
         CLI   0(R1),C'E'          SPF edit selection?
         BE    HISPFCHK            Yes, check validity
         CLI   0(R1),C'H'          History selection?
         BE    HFSHSTRY            Yes, check validity
         CLI   0(R1),C'M'          Map selection?
         BE    HFSMAPIT            Yes, check validity
         CLI   0(R1),C'S'          REVIEW selection?
         BE    DOHFSREV            Yes, proceed
         CLI   0(R1),C'/'          REVIEW selection?
         BE    SLASHENT            Yes, proceed
         CLI   0(R1),C'A'          REVIEW selection?
         BE    ASCIIENT            Yes, proceed
         MVI   MSG,24              Invalid selection code
         S     R1,SCREENBF         Get offset of problem line
         LA    R1,1(,R1)           Get position of problem code
         S     R1,SCRNCOLS
         S     R1,SCRNCOLS
         ST    R1,REVPOS           Specify cursor position
         MVC   REVCSR,=CL8'REVBUF' Specify cursor field
         B     SAMEENTS

HFSSEL   BAS   R14,GTENTNAM        Extract the specified entry name
         LH    R15,SELENTNM        Get the name length
         LA    R14,SELENTNM+2      Point to the name
         CLI   0(R14),C'/'         Relative path specified?
         BE    HFSETDIR            No, jump to new location
         CLC   =X'00024B4B',SELENTNM
         BL    SELNODOT            Not parent or self
         BE    HFSEND              Is parent
         CLC   =X'014B',SELENTNM+1 Self?
         BE    HFSTOP              Yes, show from top
SELNODOT LA    R0,$DIRNAME         Yes, point to current directory name
         L     R6,$DIRNMLN         Get its length
         AR    R0,R6               Point past it
         AH    R6,SELENTNM         Get the length of the new name
         LA    R1,L'$DIRNAME
         S     R1,$DIRNMLN         Get target length
         ICM   R15,8,HFBLANKS      Set pad character
         MVCL  R0,R14              Get the new full path name
         ST    R6,$DIRNMLN         Set the new path name length
         B     DOHFSSEL            Proceed with select

ASCIIENT OI    STATUS8,$8_A        Treat data as ASCII text
SLASHENT MVI   DATAKV+1,1          Specify 'DATA' operand
DOHFSREV LH    R1,UENMLN           Get length of entry name
         LA    R0,UENAME           Point to entry name
         L     R15,$DIRNMLN        Get current directory name length
         CLI   UEMODE,FT_DIR       Is selected entry a directory?
         BNE   HFSREVIT            No, not a navigation request
         MVI   DATAKV+1,0          Clear 'DATA' operand
         NI    STATUS8,255-$8_A    Clear ASCII request
         CLI   UENAME,C'.'         Self or parent?
         BNE   HFNOTDOT            No
         LA    R14,2
         CLR   R1,R14              Check entry name length
         BH    HFNOTDOT            Longer than two
         BL    SAMEENTS            Shorter than two (ie. one) so self
         CLI   UENAME+1,C'.'       Parent entry?
         BE    HFSEND              Yes, go up a level
HFNOTDOT LA    R14,1(R1,R15)       Get new total length
         ST    R14,$DIRNMLN        Save it
         LA    R14,$DIRNAME(R15)   Point to target
         LR    R15,R1              Get target length
         MVCL  R14,R0              Append selected directory name
         MVI   0(R14),C'/'         Append trailing slash
         B     HFGOTDIR            Refresh directory information
HFSREVIT LA    R14,0(R1,R15)       Get total path name length
         ST    R14,$PATHLEN        Save path name length
         LA    R14,$DIRNAME(R15)   Point to target
         LR    R15,R1              Get target length
         MVCL  R14,R0              Append selected file name
         LH    R1,UENMLN           Get length of entry name
         LA    R0,UENAME           Point to entry name
         MVC   UFILESIZ,UESIZEL    Make the file size accessible
         MVC   UREADCNT,UEBLKSI    Set byte count per read at 4096
         MVC   UNIXVOL,UEVOLSR+1   Copy volume serial number
*                                  Handle unexpected RACF audit data
         TR    UNIXVOL,PERIODS            from which the volser came
         CLC   UNIXVOL,UEVOLSR+1   Does volume serial look valid?
         BE    HFSOPNIT            Yes
         MVC   UNIXVOL,HFBLANKS    No, probably zFS so blank it
HFSOPNIT STH   R1,SELENTNM         Save the length
         LA    R14,SELENTNM+2      Point to target
         LA    R15,256             Get target length
         ICM   R1,8,HFBLANKS       Set pad character
         MVCL  R14,R0              Load entry name to process
         LA    R0,$PATHLEN+2       Point to character varying string
         ST    R0,$PATHPTR         Save address for binder dialog
         ICM   R0,15,EUIDORIG      Already a superuser?
         BZ    EUID_OK1            Yes, no need for UID change
         TM    STATUS13,$13NSPR    Allowed to be a superuser?
         BO    EUID_OK1            No, definitely not
         CLC   EUIDORIG,UEUID      Trying to read own file?
         BE    EUID_OK1            Yes, no need for UID change
         TM    UEMODE+3,S_IRGRP+S_IROTH
         BO    EUID_OK1            Everyone can read it anyway
         SR    R0,R0
         ST    R0,EUIDCRNT         Prepare for becoming a superuser
         BAS   R14,SETEUID         Set effective user id
         ICM   R15,15,HFSRETVL     Was seteuid successful?
         BNM   EUID_OK1            Yes, proceed
         OI    STATUS13,$13NSPR    No, remember not to try it again
         MVC   EUIDCRNT,EUIDORIG   Set correct current effective UID
EUID_OK1 XC    DEBLOCKS(12),DEBLOCKS
         XC    MAXPOINT,MAXPOINT   Reset furthest record read
         MVI   SYNADSW,X'00'       Reset SYNAD error flag
*        CALL  BPX1OPN,            Open HFS file
         L     R15,FLCCVT          CVT
         L     R15,CVTCSRT-CVT(,R15) CSRTABLE
         L     R15,24(,R15)        CSR slot
         L     R15,#BPX1OPN(,R15)  Address of the service
         CALL  (15),               Open HFS file                       +
               ($PATHLEN,$DIRNAME,HFSOPTNS,MAXPOINT, (<--MODE ignored) +
               HFSRETVL,HFSRETCD,HFSRSNCD),                            +
               VL,MF=(E,HFSPLIST)
         ICM   R6,15,HFSRETVL      Was open successful?
         BNM   HFSOPNOK            Yes, file descriptor returned
         MVI   DATAKV+1,0          No, clear 'DATA' operand
         NI    STATUS8,255-$8_A    Clear ASCII request
         MVC   MSG+2(8),=CL8'BPX1OPN '
         BAS   R14,BADBPXCL        Load error message into heading
         B     SAMEENTS

*
*               SET EFFECTIVE USER ID
*
SETEUID  ST    R14,READR           Save return address
*        CALL  BPX1SEU,            Set effective user id
         L     R15,FLCCVT          CVT
         L     R15,CVTCSRT-CVT(,R15) CSRTABLE
         L     R15,24(,R15)        CSR slot
         L     R15,#BPX1SEU(,R15)  Address of the service
         CALL  (15),               Set effective user id               +
               (EUIDCRNT,HFSRETVL,HFSRETCD,HFSRSNCD),                  +
               VL,MF=(E,HFSPLIST)
         L     R14,READR           Restore return address
         BR    R14                 Return to caller

*
*               Phony DCB usage:   +0 - File descriptor
*                                  +4 - Current file offset (high)
*                                  +8 - Current file offset (low)
*                                  +C - Saved file offset for NOTE (H)
*                                 +10 - Saved file offset for NOTE (L)
HFSOPNOK CLC   EUIDCRNT,EUIDORIG   Was the effective UID changed?
         BE    EUID_OK2            No, so no need to change it back
         MVC   EUIDCRNT,EUIDORIG   Yes, change it back
         BAS   R14,SETEUID         Set effective user id
EUID_OK2 OI    $UCBAD,$HFSIO       Flag processing UNIX files
         NI    STATUS8,255-$8ZIPF  Reset ZIP directory flag
         TM    STATUS8,$8_A        ASCII text explicitly requested?
         BO    UREDASCI            Yes
         TM    UFILESIZ+2,X'0F'    Is size a multiple of 4096?
         BNZ   UREDNT4K            No
         CLI   UFILESIZ+3,X'00'    Is size a multiple of 4096?
         BNE   UREDNT4K            No
         L     R1,UFILESIZ         Yes, get file size
         SRL   R1,12               Get record count
         BCTR  R1,0                Less one for relative
         ST    R1,MAXPOINT         Save maximum direct access value
         OI    STATUS2,$2FAST      Indicate "fastpath" availability
         B     UREDCTOK            Now using 4096 as record size
UREDNT4K LA    R14,80
         L     R1,UESIZEL          Get the size
         SR    R0,R0
         DR    R0,R14
         ST    R14,UREADCNT        Set byte count per read at 80
         LTR   R0,R0               Is size a multiple of 80?
         BNZ   UREDNT80            No
         BCTR  R1,0                Record count less one for relative
         ST    R1,MAXPOINT         Save maximum direct access value
         OI    STATUS2,$2FAST      Indicate "fastpath" availability
         B     UREDCTOK            Now using 80 as record size
UREDASCI OI    MODE,MD_ASCII       Translate ASCII text for display
UREDNT80 LA    R14,256
         ST    R14,UREADCNT        Set byte count per read at 256
UREDCTOK LA    R1,DYNDCBW          Point to DCB area
         XC    0(SEQDCBL,R1),0(R1) Clear entire "DCB"
         ST    R6,0(,R1)           Set HFS file descriptor in "DCB"
         USING IHADCB,R1
         MVC   DCBBLKSI,UREADCNT+2 Set phony block size for FAS2INIT
         MVI   DCBRECFM,X'C0'      Set phony RECFM=U for FAS2INIT
         MVI   TSTRECFM,X'00'      Behave as for RECFM=U
         L     R0,=A(USSREAD)      Set "DCB" routine addresses
         ST    R0,DCBREAD
         L     R0,=A(USSCHECK)
         ST    R0,DCBCHECK
         L     R0,=A(USSPOINT)
         ST    R0,DCBPOINT
         OI    DCBOFLGS,X'10'      Flag open success - allow NEWTOP
         L     R15,=A(SEQDCB)      Set MACRF and EODAD in "open DCB"
         MVC   DCBMACRF,DCBMACR-IHADCB(R15)
         MVC   DCBEODA,DCBEODA-IHADCB(R15)
         DROP  R1                  IHADCB
         LA    R0,PHONYIOB         Set "IOB" address in "DECB"
         ST    R0,DYNDECBW+16
         XC    TTR,TTR             Clear top TTR specification
         LA    R1,44               Get maximum showable name length
         C     R1,$PATHLEN
         BL    USEFILEN            Path too long so use file name
         L     R1,$PATHLEN         Get path name length
         LA    R0,$DIRNAME         Point to path name
         B     FNMSRCOK            Got file name source
USEFILEN LA    R0,SELENTNM+2       Point to file name
         CH    R1,SELENTNM         File name too long?
         BL    FNMSRCOK            Yes
         LH    R1,SELENTNM         No, use file name length
FNMSRCOK STH   R1,$DSNAME          Save the length
         LA    R15,44              Get target length
         LA    R14,$DSNAME+2       Point to target
         ICM   R1,8,HFBLANKS       Set pad character
         MVCL  R14,R0              Load name into heading
         MVC   $DDNAME,HFDDNAME    Supply an indicative file name
         MVC   $VOLSER,UNIXVOL     Copy volume serial number
         MVC   $MEMBER,HFBLANKS    Clear member name
         L     R15,=A(REVIEW2)     Get address of phase 2
         BASR  R14,R15             Call REVIEW phase 2
         TM    STATUS8,$8ZIPF      Need to reshow ZIP directory?
         BO    EUID_OK2            Yes, go do it
*        CALL  BPX1CLO,            Close HFS file
         L     R15,FLCCVT          CVT
         L     R15,CVTCSRT-CVT(,R15) CSRTABLE
         L     R15,24(,R15)        CSR slot
         L     R15,#BPX1CLO(,R15)  Address of the service
         CALL  (15),               Close HFS file                      +
               (DYNDCBW,HFSRETVL,HFSRETCD,HFSRSNCD),                   +
               VL,MF=(E,HFSPLIST)
         ICM   R15,15,HFSRETVL     Was close successful?
         BNM   HFSREVDN            Yes
         MVC   MSG+2(8),=CL8'BPX1CLO '
         BAS   R14,BADBPXCL        No, load error message into heading

HFSREVDN TM    STATUS,STPODIR      Still in entry select mode?
         BZ    HFSEXIT             No, exit was requested
         TM    STATUS8,$8_A        Was ASCII text explicitly requested?
         BNO   ACODEDON            No, selection code was not 'A'
         NI    STATUS8,255-$8_A    Yes, reset flag
         NI    MODE,255-MD_ASCII   Reset accompanying ASCII conversion
ACODEDON TM    UEVISAT,ST_EXTLINK  External link?
         BO    HFSTATED            Yes, do not do status update
         L     R6,$DIRNMLN         Get directory path name length
         LA    R14,$DIRNAME(R6)    Point past directory name
         LA    R15,L'$DIRNAME
         SR    R15,R6              Get length of name field after dir
         SR    R1,R1               Set source length
         SR    R0,R0               Set source address (not needed)
         ICM   R1,8,HFBLANKS       Set pad character
         MVCL  R14,R0              Clear file name from directory path
         MVI   DATAKV+1,0          Clear 'DATA' operand
         NI    STATUS2,255-$2FAST  Disable "fastpath"
         NI    STATUS9,255-$9F80   Reset LRECL override status flag
         ICM   R1,15,FMTAREA       Any format loaded?
         BZ    HFSHSTOK            No
         USING @FMTAREA,R1
         CLC   =C'*OBJ',FMTNAME
         BNE   HFSHSTOK
         NI    MODE,255-MD_FMT     Turn off binder data formatting
         DROP  R1                  @FMTAREA
HFSHSTOK LA    R0,HFSENTS          Point to the first entry
         C     R0,LSTENTAD         Got any entries?
         BNL   HFGOTDIR            No, need to read the directory
**EFRENT ICM   R0,15,TAGCOUNT      Any tagged entries?
**       BZ    HFGOTDIR            No, refresh directory information
**       Do not do a complete refresh in the hope of improving response
HREFRENT C     R4,LSTENTAD         Have an entry for this file?
         BNL   HFGOTDIR            No, probably edit of a new file
         LH    R15,UENMLN          Get file name length
         LR    R14,R15             Copy it
         L     R6,$DIRNMLN         Get directory path name length
         AR    R14,R6              Get total path length
         ST    R14,DOUBLE          Save it
         LA    R0,$DIRNAME(R6)     Point past directory name
         LA    R1,L'$DIRNAME
         SR    R1,R6               Get length of name field after dir
         LA    R14,UENAME          Point to file name
         ICM   R15,8,HFBLANKS      Set pad character
         MVCL  R0,R14              Append file name to get whole path
         XC    STAT(ST#LEN),STAT   Clear residual data for bad call
*        CALL  BPX1STA,            Get file status
         L     R15,FLCCVT          CVT
         L     R15,CVTCSRT-CVT(,R15) CSRTABLE
         L     R15,24(,R15)        CSR slot
         L     R15,#BPX1STA(,R15)  Address of the service
         CALL  (15),               Get file status                     +
               (DOUBLE,$DIRNAME,HFSTATLN,STAT,                         +
               HFSRETVL,HFSRETCD,HFSRSNCD),                            +
               VL,MF=(E,HFSPLIST)
         TM    HFSRETVL,X'80'      File status data returned?
         BNO   HFSTATOK            Yes
         XC    UEMODE,UEMODE       No, flag this
         MVC   UEUID,HFSRETCD      Save return code
         MVC   UEGID,HFSRSNCD      Save reason code
         B     HFSTATED
HFSTATOK MVC   UEMODE,ST_MODE      Copy file mode
         MVC   UESERNO,ST_INO      Copy file serial number
*        MVC   UEUID,ST_UID        Copy file owner's UID
         MVC   UEGID,ST_GID        Copy file owner's GID
         L     R15,HFSTOTSZ+4      Load old total size
         S     R15,UESIZEL         Remove old size from total
         MVC   UESIZE,ST_SIZE      Copy file size
         A     R15,UESIZEL         Add new size to total
         ST    R15,HFSTOTSZ+4      Save new total size
         MVC   UEACCDT,ST_ATIME    Copy timestamps
         MVC   UEMODDT,ST_MTIME
         MVC   UECREDT,ST_CREATETIME
         MVC   UEBLKSI,ST_BLKSIZE  Copy file block size
         MVC   UEBLOKS,ST_BLOCKS   Copy file block count
         MVC   UEVISAT,ST_VISIBLE  Copy file visible attributes
         MVC   UEVOLSR,ST_AUDITID  Copy half of RACF file id
         MVC   UEFMT,ST_FILEFMT    Copy file format
HFSTATED L     R6,$DIRNMLN         Get directory path name length
         LA    R14,$DIRNAME(R6)    Point past directory name
         LA    R15,L'$DIRNAME
         SR    R15,R6              Get length of name field after dir
         SR    R1,R1               Set source length
         SR    R0,R0               Set source address (not needed)
         ICM   R1,8,HFBLANKS       Set pad character
         MVCL  R14,R0              Clear file name from directory path
         TM    MODE,MD_OFFLD       Currently searching files?
         BO    HSCHRETN            Yes, check search result
         TM    STATUS3,$3SORT      Showing in name order?
         BNZ   FINDENT             No, reshow list from the file
         ST    R4,CURENTAD         Yes, save this entry's address
         L     R3,TOPENTAD         Point to previous top entry
         CLC   ISPFPAGE,ENTRYCNT   Can all entries be shown at once?
         BNH   THISENT             No, do not scroll
         LA    R3,HFSENTS          Yes, point to first entry
         B     THISENT             Show all entries


HFSMAPIT OI    STATUS9,$9_M        Signal function request code
         B     *+8                 Do not set other flag
HFSHSTRY OI    STATUS9,$9_H        Signal function request code
         CLI   UEMODE,FT_REGFILE   Regular file?
         BNE   HFNOHIST            No, can't be a program object
         TM    UESIZEL+2,X'0F'     Is size a multiple of 4096?
         BNZ   HFNOHIST            No, can't be a program object
         CLI   UESIZEL+3,X'00'     Is size a multiple of 4096?
         BNE   HFNOHIST            No, can't be a program object
         TM    S_MODE3,S_IXUSR+S_IXGRP+S_IXOTH
         BNZ   DOHFSREV            Some execute permission(s) set

HFNOHIST MVI   MSG,90              Selected entry is not a program
         NI    STATUS9,255-$9_H-$9_M  Reset whichever flag was set
         B     SAMEENTS            Go show the message


HFSPFCMD BAS   R14,GTENTNAM        Extract the specified entry name
         LH    R0,SELENTNM         Get the name length
         LA    R1,SELENTNM+2       Point to the name
HFSSLSLP CLI   0(R1),C'/'          Found a slash?
         BE    BADSLASH            Yes, invalid
         LA    R1,1(,R1)           Point to the next character
         BCT   R0,HFSSLSLP         Go check it
         LA    R4,HFSENTS          Point to first entry
HFSSPFLP C     R4,LSTENTAD         Reached end of entries?
         BNL   HFSPFNOT            Yes, stop scanning
         LA    R0,SELENTNM+2       Point to requested name
         LH    R1,SELENTNM         Get length of requested name
         LA    R14,UENAME          Point to entry's name
         LH    R15,UENMLN          Get length of entry's name
         ICM   R15,8,HFBLANKS      Set pad character
         CLCL  R0,R14              Up to required file?
         L     R1,OPD0             Point to the subcommand name
         BE    HISPFCHK            Yes, found it
         AH    R4,UELEN            Point to next entry
         B     HFSSPFLP            Keep looking for the entry
HFSPFNOT L     R1,OPD0             Point to the subcommand name
         CLI   0(R1),C'E'          Edit requested?
         BE    HFSDOSPF            Yes, go do it
         MVI   MSG,98              File not found
         B     DSPLYHFS            Go display this message
BADSLASH MVI   MSG,104             File name cannot contain slash
         B     DSPLYHFS            Go display this message
HISPFCHK CLI   UEMODE,FT_REGFILE   Regular file?
         BNE   HFNOTREG            No, can't edit or browse it
         LH    R3,UENMLN           Get length of entry name
         LA    R2,UENAME           Point to entry name
         STH   R3,SELENTNM         Save the length
         LA    R14,SELENTNM+2      Point to target
         LA    R15,256             Get target length
         ICM   R3,8,HFBLANKS       Set pad character
         MVCL  R14,R2              Load entry name to process
         MVC   UFILESIZ,UESIZEL    Make the file size accessible
HFSDOSPF L     R15,=A(REVISPF)     Edit is a valid selection
         BASR  R14,R15             Call REVISPF
         CLI   0(R1),C'E'          Was the file edited?
         BNE   *+8                 No, can't have been saved
         OI    STATUS7,$7SAVE      Flag file saved by edit
         LTR   R15,R15             Was the file saved?  Browse ok?
         BZ    HREFRENT            Yes, refresh directory information
         NI    STATUS7,255-$7SAVE  No, ensure correct flag
         CLI   DOUBLE+3,4          Was there an error?
         BE    HREFRENT            No, refresh directory information
         CLI   DOUBLE+3,16         Was the file found?
         BE    HREFRENT            No, magically refresh file list
         CLI   DOUBLE+3,14         Was the file in use or not found?
         BNE   NOTPDF14            No
         MVI   MSG,99              File in use
         CLI   0(R1),C'B'          Was the file browsed?
         BNE   FINDENT             No, reshow list from the file
         MVI   MSG,98              File not found
         B     FINDENT             Reshow list from the file
NOTPDF14 CLI   DOUBLE+3,12         Was the file empty?
         BNE   FINDENT             No
         MVI   MSG,97              Empty file
         B     FINDENT             Reshow list from the file

HFNOTREG MVI   MSG,94              Action only valid for regular file
         B     SAMEENTS            Go show the message


TAGFILE  TM    UEFLAGS,UETAG       Already tagged?
         BNZ   HFSSELLP            Yes, take no action
         OI    UEFLAGS,UETAG       No, tag it now
         LA    R0,1
         A     R0,TAGCOUNT         Increment tagged entry counter
         ST    R0,TAGCOUNT
         B     HFSSELLP

RESFILE  TM    UEFLAGS,UETAG       Is the entry tagged?
         BZ    HFSSELLP            No, take no action
         NI    UEFLAGS,255-UETAG   Reset tag flag
         ICM   R0,15,TAGCOUNT      Get current tagged entry count
         BZ    HFSSELLP            Already zero so skip decrement
         BCTR  R0,0                Decrement tagged entry counter
         ST    R0,TAGCOUNT
         B     HFSSELLP

         DROP  R4                  @UNIXENT


************************************************************
*                                                          *
*         TOGGLE TAG FLAG FOR ALL ENTRIES                  *
*                                                          *
************************************************************

HTAGFLIP SR    R14,R14             Flip all tag bits
         ST    R14,TAGCOUNT        Reset tagged entry counter
         LA    R15,HFSENTS         Point to first entry
         USING @UNIXENT,R15
HTAGLOOP C     R15,LSTENTAD        Reached end of entry list?
         BNL   HFSELCHK            Yes, now look at entry selection(s)
         XI    UEFLAGS,UETAG       No, toggle tag flag
         TM    UEFLAGS,UETAG       Is the entry now tagged?
         BZ    HTAGCTOK            No, now untagged so do not count
         LA    R14,1(,R14)         Yes, increment counter
         ST    R14,TAGCOUNT        Update counter in case last tag
HTAGCTOK AH    R15,UELEN           Point to next entry
         B     HTAGLOOP            Process next entry
         DROP  R15                 @UNIXENT


************************************************************
*                                                          *
*         DISPLAY FROM THE NEXT TAGGED ENTRY               *
*                                                          *
************************************************************

HFINDTAG ICM   R0,15,TAGCOUNT      Any tagged entries?
         BZ    HFSNOTAG            No, nothing to find
         L     R3,TOPENTAD         Point to the current top entry
         C     R3,LSTENTAD         Is it end-of-directory?
         BL    HFNDTAGL            No
         LA    R3,HFSENTS          Yes, point to the first entry
         B     HFNDTAG1            Handle if first entry tagged
         USING @UNIXENT,R3
HFNDTAGL AH    R3,UELEN            Point to next entry
HFNDTAG1 C     R3,LSTENTAD         Reached end of directory?
         BNL   THISENT             Yes, end current scan
         TM    UEFLAGS,UETAG       Is this entry tagged?
         BO    THISENT             Yes, tagged entry found
         B     HFNDTAGL            Continue scan
         DROP  R3                  @UNIXENT
HFSNOTAG MVI   MSG,93              No entries are tagged
         B     SAMEENTS            Go show the message


************************************************************
*                                                          *
*         UNTAG ALL ENTRIES WITHOUT REFRESH FROM DASD      *
*                                                          *
************************************************************

HTAGREST SR    R0,R0               Reset all tag flags
         ST    R0,TAGCOUNT         No entries will be tagged
         LA    R3,HFSENTS          Point to the first entry
         USING @UNIXENT,R3
HTAGRESL C     R3,LSTENTAD         End of entry list?
         BNL   SAMEENTS            Yes
         NI    UEFLAGS,255-UETAG   Reset entry tag flag
         AH    R3,UELEN            No, point to next entry
         B     HTAGRESL            Continue pass
         DROP  R3                  @UNIXENT


************************************************************
*                                                          *
*         PREPARE FOR DIRECTORY REFRESH                    *
*                                                          *
************************************************************

         USING @UNIXENT,R3
HFSRFRSH L     R3,TOPENTAD         Point to the current top entry
         LH    R1,UENMLN           Get length of entry name
         LA    R0,UENAME           Point to entry name
         STH   R1,SELENTNM         Save the length
         LA    R14,SELENTNM+2      Point to target
         LA    R15,256             Get target length
         ICM   R1,8,HFBLANKS       Set pad character
         MVCL  R14,R0              Load entry name to process
         B     HREFRESH            Go get latest data from disk
         DROP  R3                  @UNIXENT


************************************************************
*                                                          *
*         PREPARE ERROR MESSAGE AFTER BAD BPX CALL         *
*                                                          *
************************************************************

BADBPXCL MVC   MSG+2+8(12),HFSBADRC
         MVI   MSG+2+20,C'-'
         MVC   MSG+2+21(L'MSG+2-21),MSG+2+20
         UNPK  MSG+2+20(9),HFSRETCD(5)
         TR    MSG+2+20(8),HFSHEX-C'0'
         MVC   MSG+2+28(5),HFSRSNEQ
         UNPK  MSG+2+33(9),HFSRSNCD(5)
         TR    MSG+2+33(8),HFSHEX-C'0'
         MVI   MSG+2+41,C' '
         LA    R0,41
         STH   R0,MSG              Set message length
         OI    STATUS7,$7BELL      Request audible alarm
         BR    R14                 Return to caller


************************************************************
*                                                          *
*         PROCESS SEARCH REQUEST                           *
*                                                          *
************************************************************

HFSEARCH LA    R15,HFSENTS         Point to first entry
         C     R15,LSTENTAD        Any entries in this directory?
         BNL   HFNOENTS            No, nothing to do
         LH    R1,OPD1+4           Yes, get operand length
         LTR   R0,R1               Null string?
         BNP   HFDOSRCH            Yes, as if no operand
         BCTR  R0,0                Get length code
         STH   R0,STRINGL          Save it
         L     R0,OPD1             Point to operand
         LA    R14,STRING          Point to target
         LA    R15,L'STRING        Get its length
         MVCL  R14,R0              Load search string
         ST    R15,FINDCOL1        Reset columns
         MVI   FINDCOL2,X'7F'
         MVI   FINDSW,0            Reset FIND options
         MVI   FINDSW2,FUOL
HFDOSRCH EQU   *
         USING @UNIXENT,R15
         ICM   R1,15,TAGCOUNT      Are any entries tagged?
         ST    R1,HSCHTCNT         Save the pre-search tag count
         BNZ   HSCHTGLP            Yes, untag unless regular files
HSCHRFLP CLI   UEMODE,FT_REGFILE   Regular file?
         BNE   HSCHNXRF            No, leave untagged
         OI    UEFLAGS,UETAG       Yes, tag entry
         LA    R1,1(,R1)           Increment tagged entry count
HSCHNXRF AH    R15,UELEN           Point to the next entry
         C     R15,LSTENTAD        End of internal entries?
         BL    HSCHRFLP            No, process next entry
         B     HSCHTGOK
HSCHTGLP CLI   UEMODE,FT_REGFILE   Regular file?
         BE    HSCHNXTG            Yes, do not alter tag status
         TM    UEFLAGS,UETAG       Is this entry tagged?
         BZ    HSCHNXTG            No, do not alter tag status
         NI    UEFLAGS,255-UETAG   Yes, untag entry
         BCTR  R1,0                Decrement tagged entry count
HSCHNXTG AH    R15,UELEN           Point to the next entry
         C     R15,LSTENTAD        End of internal entries?
         BL    HSCHTGLP            No, process next entry
HSCHTGOK ST    R1,TAGCOUNT         Update tagged entry count
         LTR   R1,R1               Got anything to do?
         BNP   HFNOENTS            No
         DROP  R15                 @UNIXENT
*         Now regular files can be the only tagged entries
         L     R15,=A(REVSRCH)     Point to search processor routine
         BASR  R14,R15             Call search processor
         OI    STATUS7,$7BELL      Supply WCC to sound the bell
         TM    STATUS4,$4ATTN      Attention interrupt?
         BO    HSCHATTN            Yes, notify user
         MVI   MSG,86              Search cancelled
         CLI   REPLY,X'7D'         Enter AID present?
         BNE   HSCHTIDY            No, search has been cancelled

         SR    R0,R0               Request okay so process entries
         ST    R0,HSCHFCNT         No entries matched yet
         ST    R0,HSCHMDON         No entries searched yet
         ST    R0,HSCHPCT1         Zero percent done
         ST    R0,HSCHPCT2         Zero percent done
         MVC   HSCHMTCH,NOEMATCH   No file matched yet
         MVC   HSCHLINE(PCNTLNHL+PCNTLNTL),HPCTLNHD
         MVC   HSCHLINE+PCSRCHOF+1(7),HSCHLINE+PCSRCHOF
         MVI   HSCHLINE+PCSRCHOF+7,C'0' Assume no entries processed
         MVC   HSCHLINE+PCMTCHOF(8),HSCHLINE+PCSRCHOF
         LA    R1,HSCHLINE         Point to start of data stream
         LA    R0,PCNTLNHL+PCNTLNTL Get length of data stream
         L     R1,SCREENWK         Point to RMODE=24 TPUT buffer
         MVC   0(160,R1),HSCHLINE  Load data stream
         ICM   R1,8,=X'03'         Load TPUT flags (fullscreen)
         TPUT  (1),(0),R           Show initial progress bar
         TIME  BIN                 Get the time
         ST    R0,HSCHBRTM         Save it
         OI    MODE,MD_OFFLD       Now in offload mode
         OI    FINDSW2,FALL        Employ "FIND ALL" logic
         NI    MODE,255-MD_ASCII   Ensure ASCII is off
         LA    R4,HFSENTS          Point to first internal entry

         USING @UNIXENT,R4
SCHENTLP C     R4,LSTENTAD         End of internal directory entries?
         BNL   HSCHEXIT            Yes, end up
         CLI   HSCHPCT1+3,50       Shown 100% progress bar?
         BE    HSCHEXIT            Yes, terminate search
         TM    STATUS4,$4ATTN      Attention interrupt?
         BNO   HSCHDOIT            No, proceed with search
         NI    UEFLAGS,255-UETAG   Yes, untag entry
         AH    R4,UELEN            Point to next internal entry
         B     SCHENTLP            Reset remaining entries
HSCHDOIT TM    UEFLAGS,UETAG       Is this entry tagged?
         BZ    SCHNXTFL            No, ignore untagged entry
         LA    R15,1               Yes
         A     R15,HSCHMDON        Increment searched file count
         ST    R15,HSCHMDON
         M     R14,=F'50'
         D     R14,TAGCOUNT        Get half the percentage done
         ST    R15,HSCHPCT2        Save it
         SR    R0,R0
         STH   R0,RC               Zero any previous file failure
         ST    R0,CALLPARM         Zero the signal area
         B     DOHFSREV            Go open the file

HSCHRETN TM    STATUS4,$4ATTN      Attention interrupt?
         BO    SCHENTLP            Yes, abort search
         CLI   CALLPARM,0          Search match?
         BE    SCHENTNO            No, untag file
         LA    R0,1
         A     R0,HSCHFCNT         Increment tagged file count
         ST    R0,HSCHFCNT
         LA    R0,8                Get maximum supported name length
         LH    R14,UENMLN          Get actual name length
         CLR   R14,R0              Too long?
         BNH   *+6                 No
         LR    R14,R0              Yes, reduce to maximum
         MVC   HSCHMTCH,HFBLANKS   Clear residual data
         BCTR  R14,0               Decrement for execute
         EX    R14,HSETMTCH        Update latest match file name
         B     SCHNXTFL            Leave file tagged
HSETMTCH MVC   HSCHMTCH(0),UENAME  <<< Executed >>>
SCHENTNO NI    UEFLAGS,255-UETAG   Reset file tag flag
SCHNXTFL AH    R4,UELEN            Point to next internal entry
         CLI   HSCHPCT2+3,50       Has the last file been processed?
         BE    HFSDOBAR            Yes, show 100% before exiting
         TIME  BIN                 No, get the time
         LA    R1,100
         A     R1,HSCHBRTM
         CR    R1,R0               At least 1 second since last update?
         BH    SCHENTLP            No, skip update at this time
         CLC   HSCHPCT1,HSCHPCT2   Need to update progress bar?
         BNE   HFSDOBAR            Yes, update the screen
         LA    R1,300              Same percentage,
         A     R1,HSCHBRTM              but have three seconds
         CR    R1,R0                    elapsed since last update?
         BH    SCHENTLP            No, skip update at this time
HFSDOBAR MVC   HSCHPCT1,HSCHPCT2   Yes, proceed with update
         ST    R0,HSCHBRTM         Save current time
         MVC   HSCHLINE(PCNTLNHL),HPCTLNHD
         L     R0,HSCHMDON         Show number of entries searched
         CVD   R0,DOUBLE
         ED    HSCHLINE+PCSRCHOF(8),DOUBLE+4
         L     R0,HSCHFCNT         Show number of entries matched
         CVD   R0,DOUBLE
         ED    HSCHLINE+PCMTCHOF(8),DOUBLE+4
         MVC   HSCHLINE+PCLATEOF(8),HSCHMTCH
*                                  Handle bad file name code points
         TR    HSCHLINE+PCLATEOF(8),PERIODS
         LA    R2,HSCHLINE+PCNTLNHL
         TM    STATUS5,$5EDS       Using extended data stream orders?
         BZ    HFSVIDOK            No, don't use reverse video
         MVC   0(3,R2),HFSRVERS    Set reverse video
         LA    R2,3(,R2)           Update pointer
HFSVIDOK CLI   HSCHPCT2+3,1        Just one byte in progress bar?
         BE    HFSRTAOK            Yes, skip repeat-to-address
         BL    HFSLENOK            Zero bytes so forget bar display
         MVI   0(R2),RA
         L     R1,HSCHPCT2         Get half of new percent to show
         LA    R1,SRCHPBAR(,R1)    Get final location
         L     R15,=A(CALCPOSI)    Get conversion routine entry point
         BASR  R14,R15             Convert for 3270 data stream
         STCM  R1,3,1(R2)          Set ending 3270 buffer address
         LA    R2,3(,R2)           Point to progress bar character
HFSRTAOK MVI   0(R2),C'X'          Load character for bar
         TM    STATUS5,$5EDS       Using extended data stream orders?
         BZ    *+8                 No, leave the 'x'
         MVI   0(R2),C' '          Yes, use reverse video blanks
         CLI   SACHAR,X'0E'        Fujitsu terminal hardware?
         BNE   HFSBAROK            No, terminal will reset to normal
         MVC   1(3,R2),HFSNORML    Reset to normal video for next write
         LA    R2,3(,R2)           Update pointer
HFSBAROK LA    R2,1(,R2)           Update pointer
HFSLENOK LR    R0,R2               Point past end of data stream
         LA    R1,HSCHLINE         Point to start of data stream
         SR    R0,R1               Get length of data stream
         L     R1,SCREENWK         Point to RMODE=24 TPUT buffer
         MVC   0(160,R1),HSCHLINE  Load data stream
         ICM   R1,8,=X'03'         Load TPUT flags (fullscreen)
         TPUT  (1),(0),R           Update the progress bar
         B     SCHENTLP            Process the next directory entry
         DROP  R4                  @UNIXENT

HSCHEXIT NI    MODE,255-MD_OFFLD   Ensure search flags are reset
         NI    FINDSW2,255-FALL
         L     R0,HSCHFCNT         Get matched entry count
         ST    R0,TAGCOUNT         Set tagged file count
         CVD   R0,DOUBLE
         MVI   MSG,87              Search complete
         L     R15,=A(REVMSGS)
         BASR  R14,R15             Fetch message text
         MVC   MSG+2+17(10),ED9H
         ED    MSG+2+17(10),DOUBLE+3
         MVC   MSG+2+28(6),=c'entrie'
         LH    R0,MSG              Get the length of msg87
HSCHDMLP CLI   MSG+2+18,C' '       Leading blank?
         BNE   SAMEENTS            No, message formatted
         MVC   MSG+2+18(25),MSG+2+19
         BCTR  R0,0
         STH   R0,MSG              Decrement message length
         B     HSCHDMLP            Repeat leading blank check
HSCHATTN MVI   MSG,85              Search interrupted
HSCHTIDY ICM   R0,15,HSCHTCNT      Were any entries initially tagged?
         BNP   HTAGREST            No, so untag everything now
         B     SAMEENTS            Notify user of search cancellation
         TITLE '  R E V U N I X   -   S T A T I C   A R E A  '
HFPRICOL DC    H'80'               Expected primary screen size width
LASTFILE DC    H'4',H'0'
LASTENT  DC    H'10',H'0',2H'0',H'10'
REVHU00  DC    CL8'REVHU00 '       Name of first REVUNIX help panel
HFSHEX   DC    C'0123456789ABCDEF' Hexadecimal digit translate table
HFBLANKS DC    CL8' '
HFDDNAME DC    CL8'**UNIX**'
HFSBADRC DC    CL12'FAILED - RC='
HFSRSNEQ DC    CL5' RSN='
EODIRTXT DC    CL7'**END**'
**  The following must be kept in sync with the data after PCNTLNHD. **
HPCTLNHD DC    AL1(WCCNULL,SBA)                                      **
         DCS   (21,6)                                                **
         DC    X'4020202020202120' Edit mask for entries searched    **
         DC    C' ENTRIES SEARCHED  '                                **
         DC    X'4020202020202120' Edit mask for entries matched     **
         DC    C' ENTRIES MATCHED - LATEST: '                        **
NOEMATCH DC    C'**NONE**'                                           **
         DCS   SBA,(22,13),C'0% '                                    **
         DCS   RA,(22,66),C'_ 100%'                                  **
**  The previous must be kept in sync with the data after PCNTLNHD.  **
HFSRVERS DC    AL1(SA,HILT,RVRSE)                                    **
HFSNORML DC    AL1(SA,HILT,NULL)                                     **
HFSED11  DC    X'402020202020202020202120'
HFS2GIG  DC    P'2147483648'       Unsigned value of top binary bit
HFSTATLN DC    A(ST#LEN)           Length of file status area
HFSOPTNS DC    A(O_RDONLY)         Open options

         LTORG

ED7DASH  DC    XL8'6020202020202120'
ED9H     DC    X'40202020202020202120'
HFSNMLBL DC    C'Name (Link-Symbol)'
HFSUBHDW DC    C'Created  '
HFSUBHDG DC    C'Last Accessed  Last Modified      Size Owner   Mode Fl+
               ags'
HFSUBHDL EQU   *-HFSUBHDG

         DS    0H
         TITLE '  R E V U N I X  '
************************************************************
*                                                          *
*         FORMAT DIRECTORY ENTRY SCREEN LINE               *
*                                                          *
************************************************************

         USING HFSFRMAT,R7
         USING @UNIXENT,R3
HFSFRMAT DS    0H                  Format directory entry
         LR    R4,R2               Point to primary buffer line
         A     R4,SCREENSZ         Point to shadow buffer line
         MVI   0(R2),FLDINHI       High intensity for selection field
         MVI   1(R2),C'.'          Supply auto-selection dot
         MVI   1(R4),X'01'         Blue for auto-selection dot
         MVI   2(R2),FLDOUTLO      Low intensity for entry attributes
         C     R3,CURENTAD         Processed this entry?
         BNE   HFSCUROK            No
         LA    R14,2(,R2)          Yes, point past period
         S     R14,SCREENBF        Get position of period
         MVI   1(R2),C' '          Clear auto-selection dot
         SR    R0,R0               Get zero
         S     R14,SCRNCOLS
         S     R14,SCRNCOLS
         ST    R14,REVPOS          Specify cursor position
         MVC   REVCSR,=CL8'REVBUF' Specify cursor field
         ST    R0,CURENTAD         Clear pending cursor placement
HFSCUROK MVC   3(1,R4),UEMODE      Copy file type
         NI    3(R4),X'0F'         Ensure it is in expected range
         TR    3(1,R4),HFSCOLRS    Convert to colour flag
         CLI   UEMODE,FT_REGFILE   Is it a regular file?
         BNE   HFEXECOK            No, skip check for executable
         TM    UEMODE+3,S_IXUSR+S_IXGRP+S_IXOTH
         BZ    HFEXECOK            No execute permissions
         MVI   3(R4),X'04'         Show executable in green
HFEXECOK L     R14,SCRNCOLS        Get screen width
         LA    R0,5
         SR    R14,R0              Get attributes length code
         EX    R14,HFSPREAD        Spread attributes along screen line
         TM    UEFLAGS,UETAG       Is this entry tagged?
         BNO   HFSTAGOK            No, leave as low intensity
         MVI   2(R2),FLDOUTHI      Yes, high intensity for tagged entry
         NI    3(R4),X'0F'         Remove any highlighting present
         OI    3(R4),X'20'         Use reverse video to show tag
         LH    R14,UENMLN          Get the name length
         LA    R0,157              Get maximum name length to show
         CLR   R14,R0              Too big?
         BNH   *+6                 No
         LR    R14,R0              Yes, reduce to maximum
         BCTR  R14,0               Decrement for execute
         EX    R14,HFSPREAD        Highlight tagged name
HFSTAGOK CLI   UEMODE,FT_DIR       Directory?
         BNE   ENTATTRS            No
         ICM   R14,15,TAGCOUNT     Any members tagged?
         BNZ   ENTATTRS            Yes, highlight tagged members only
         MVI   2(R2),FLDOUTHI      No, make it high intensity
ENTATTRS LA    R0,80
         LR    R6,R2               Copy line pointer
         A     R6,SCRNCOLS         Point to next line
         SLR   R6,R0               Point back to current format area
         CLI   UEMODE,0            File status acquired successfully?
         BNE   HFSFMTUE            Yes
         MVC   25(7,R6),=CL7'BPX1STA'
         MVC   33(12,R6),HFSBADRC
         UNPK  45(9,R6),UEUID(5)
         TR    45(8,R6),HFSHEX-C'0'
         MVC   53(5,R6),HFSRSNEQ
         UNPK  58(9,R6),UEGID(5)
         TR    58(8,R6),HFSHEX-C'0'
         MVC   66(5,R6),=CL5' INO='
         UNPK  71(9,R6),UESERNO(5)
         TR    71(8,R6),HFSHEX-C'0'
         MVI   79(R6),C' '
         B     HFSTMSOK
HFSFMTUE OC    UESIZE,UESIZE       Zero bytes in file?
         BZ    HFSIZEOK            Yes, skip size formatting
         LM    R14,R15,UESIZE      Get file size
         SRDL  R14,10              Divide by 1024
         SLDL  R14,10              Multiply by 1024
         CL    R15,UESIZEL         Is size a multiple of 1024?
         BE    HFSKILOS            Yes, go show kilobytes
         L     R15,UESIZEL         No, reload exact byte count
         LA    R15,0(,R15)         Clear sign bit
         CVD   R15,DOUBLE
         TM    UESIZEL,X'80'       File larger than 2GB?
         BZ    HFS2GBOK            No
         AP    DOUBLE,HFS2GIG      Yes, correct the count
HFS2GBOK MVC   49(12,R6),HFSED11   Load edit mask
         ED    49(12,R6),DOUBLE+2  Show byte count
         B     HFSIZEOK
HFSKILOS SRDL  R14,10              Divide by 1024 (again)
         CVD   R15,DOUBLE
         MVC   48(12,R6),HFSED11   Load edit mask
         ED    48(12,R6),DOUBLE+2  Show byte count
         MVI   60(R6),C'K'         Denote kilobytes
HFSIZEOK MVC   62(8,R6),UEOWNER    Show RACF userid name of owner
         MVC   70(1,R6),UEMODE     Copy file type
         NI    70(R6),X'0F'        Ensure it is in expected range
         TR    70(1,R6),HFSTYPES   Convert to display flag
         L     R0,UEMODE           Get file mode
         SLL   R0,32-9             Promote 9 auth bits
         LA    R15,71(,R6)         Point to output area
         LA    R1,HFSAUTHS         Point to flags
         MVI   0(R15),C'-'         Prime display area with dashes
         MVC   1(8,R15),0(R15)
         LA    R14,9               Get bit count
HFAUTHLP LTR   R0,R0               Is auth bit on?
         BNM   HFAUTHNX            No, go for next bit
         MVC   0(1,R15),0(R1)      Yes, load display flag
HFAUTHNX LA    R15,1(,R15)         Point to next display byte
         LA    R1,1(,R1)           Point to next display flag
         SLL   R0,1                Promote next bit to sign
         BCT   R14,HFAUTHLP        Process next bit
         TM    UEMODE+2,S_ISUID    Set user id on execution?
         BNO   SETUIDOK            No
         MVI   73(R6),C'S'-C' '    Yes, flag with 's'
         TM    UEMODE+3,S_IXUSR    Execute/search as well?
         BO    SETUIDOK            Yes
         MVI   73(R6),C'S'         No, show an upper case 's'
SETUIDOK TM    UEMODE+2,S_ISGID    Set group id on execution?
         BNO   SETGIDOK            No
         MVI   76(R6),C'S'-C' '    Yes, flag with 's'
         TM    UEMODE+3,S_IXGRP    Execute/search as well?
         BO    SETGIDOK            Yes
         MVI   76(R6),C'S'         No, show an upper case 's'
SETGIDOK TM    UEMODE+2,S_ISVTX    Is sticky bit set?
         BNO   *+8                 No
         MVI   79(R6),C'T'-C' '    Yes, flag with 't'
         TM    UEVISAT,ST_NOSHAREAS
         BNO   *+8                 No
         MVI   70(R6),C'N'-C' '    Yes, flag with 'n'
         TM    UEVISAT,ST_APFAUTH  APF authorised?
         BNO   *+8                 No
         MVI   70(R6),C'A'         Yes, flag with 'A'
         TM    UEVISAT,ST_NOSHAREAS+ST_APFAUTH  BOTH?
         BNO   *+8                 No
         MVI   70(R6),C'N'         Yes, flag with 'N'
         TM    UEVISAT,ST_EXTLINK  External link?
         BNO   *+8                 No
         MVI   70(R6),C'E'-C' '    Yes, flag with 'e'
         L     R15,UEMODDT         Get last change timestamp
         LA    R8,37(,R6)          Point to display area
         BAS   R4,HFSFMTTM         Format the timestamp
         L     R15,UEACCDT         Get last access timestamp
         LA    R8,22(,R6)          Point to display area
         BAS   R4,HFSFMTTM         Format the timestamp
         CLI   SCRNCOLS+3,95       Screen wider than 94 columns?
         BL    HFSTMSOK            No
         L     R15,UECREDT         Get creation timestamp
         LA    R8,7(,R6)           Point to display area
         BAS   R4,HFSFMTTM         Format the timestamp
HFSTMSOK L     R0,SCRNCOLS         Get the screen width
         LA    R14,3               Must not run into shadow buffer
         SR    R0,R14              Get maximum name length to show
         LH    R14,UENMLN          Get the name length
         CLR   R14,R0              Too big?
         BNH   *+6                 No
         LR    R14,R0              Yes, reduce to maximum
         LR    R15,R2              Point to display line
         LA    R1,UENAME           Point to the entry name
         BCTR  R14,0               Decrement for execute
         EX    R14,HFSLDENM        Load entry name
         EX    R14,HFSTRENM        Handle strange entry names
         TM    UEFLAGS,UESYM       Symbol value present?
         BNO   HFSLNKOK            No
         LA    R0,7                Get length code of eight byte name
         CR    R14,R0              Was the name shorter?
         BNL   HFSDOLNK            No
         LR    R14,R0              Yes, set left-most link start column
HFSDOLNK LA    R15,2(R14,R15)      Point to second-last byte of name
         MVI   2(R15),C'('         Show symbol value in parentheses
         AH    R1,UENMLN           Point to the symbol value
         IC    R14,UESYML          Get the symbol value length
         A     R15,SCREENSZ        Point to shadow buffer
         MVI   2(R15),X'05'        Show link in turquoise
         EX    R14,HFSLNKAT        Propagate colour for whole name
         S     R15,SCREENSZ        Point back to primary buffer
         BCTR  R14,0               Decrement for execute
         EX    R14,HFSLDENM        Load symbol value
         EX    R14,HFSTRENM        Handle strange entry names
         LA    R1,4(R14,R15)       Point past symbol value
         MVI   0(R1),C')'
         MVI   1(R1),C' '          Separate name from stat data
         CLI   3(R1),C' '          Possibly just one non-blank?
         BNE   HFSLNKOK            No
         MVI   2(R1),C' '          Yes, erase useless non-blank
HFSLNKOK A     R2,SCRNCOLS         Point to next detail screen line
         AH    R3,UELEN            Point to next entry
         BCT   R5,LODENTNM
         B     DSPLYHFS
HFSPREAD MVC   4(0,R4),3(R4)       <<< Executed >>>
HFSLDENM MVC   3(0,R15),0(R1)      <<< Executed >>>
HFSTRENM TR    3(0,R15),PERIODS    <<< Executed >>>
HFSLNKAT MVC   3(0,R15),2(R15)     <<< Executed >>>

         DROP  R3                  @UNIXENT

HFSFMTTM M     R14,=F'1000000'     Convert to microseconds
         LA    R0,1                Get one
         AL    R15,SEC70YRS+4      Change origin from 1970 to 1900
         BC    12,HFSFMTL1
         ALR   R14,R0              Carry one from overflow
HFSFMTL1 AL    R14,SEC70YRS
         SLDL  R14,12              Convert to STCK format
         L     R1,FLCCVT           CVT
         L     R1,CVTEXT2-CVT(,R1) OS/VS2 common extension
         USING CVTXTNT2,R1
         AL    R15,CVTLDTOR        Add CVTLDTO right word
         BC    12,HFSFMTL2         CVTLDTO = Local Date/Time Offset
         ALR   R14,R0              Carry one from overflow
HFSFMTL2 AL    R14,CVTLDTOL        Add CVTLDTO left word
         SL    R15,CVTLSOL         Subtract CVTLSO low word
         BC    3,HFSFMTL3          CVTLSO = Leap Second Offset
         SR    R14,R0              Borrow one from overflow
HFSFMTL3 SL    R14,CVTLSOH         Subtract CVTLSO high word
         DROP  R1                  CVTXTNT2
         STM   R14,R15,DOUBLE      Save the STCK value
         STCKCONV STCKVAL=DOUBLE,  Point to input STCK value           +
               CONVVAL=SBASAVE,    Point to output four words          +
               TIMETYPE=DEC,       Get time decimal digits (default)   +
               DATETYPE=YYYYMMDD,  Specify date format                 +
               MF=(E,STCKCNVL)     Specify parameter list
         UNPK  0(3,R8),SBASAVE+9(2)  Show the year
         UNPK  3(3,R8),SBASAVE+10(2) Show the month
         UNPK  6(3,R8),SBASAVE+11(2) Show the day
         UNPK  9(3,R8),SBASAVE(2)    Show the hour
         UNPK  12(3,R8),SBASAVE+1(2) Show the minute
         TR    0(14,R8),HFSHEX-240 Handle bad decimal digits
         MVI   2(R8),C'-'          Supply separators and
         MVI   5(R8),C'-'                 tidy up after translate
         MVI   8(R8),C' '                 and the last unpack
         MVI   11(R8),C':'
         MVI   14(R8),C' '
         BR    R4                  Return to caller

         DROP  R7                  HFSFRMAT


HFSCOLRS DC    X'0201060706320603020202020202020202'
HFSTYPES DC    X'F0848360979382A2F8F96F6F6F6F6F6F6F'
*   FILE TYPES:     D C - P L B S    COLOURS: -REVIEW- -----LINUX------
*        D - DIRECTORY                        BLUE     BLUE     BOLD
*        C - CHARACTER SPECIAL FILE           YELLOW   YELLOW   BOLD
*        - - REGULAR FILE                     WHITE    GREY
*        P - NAMED PIPE (FIFO) SPECIAL FILE   YELLOW   YELLOW
*        L - SYMBOLIC LINK       GOOD/BROKEN: TURQ/RED CYAN/RED BOLD/US
*        B - RESERVED FOR BLOCK SPECIAL FILE  YELLOW   YELLOW   BOLD
*        S - SOCKET FILE                      PINK     MAGENTA  BOLD
*                                 EXECUTABLE: GREEN    GREEN    BOLD
*      ARCHIVE WITHOUT EXECUTABLE PERMISSION:          RED
*      GRAPHIC WITHOUT EXECUTABLE PERMISSION:          MAGENTA

HFSAUTHS DC    X'99A6A799A6A799A6A7'
*        S - SHARED LIBRARY
*        N - NO SHAREAS
*        A - APF AUTHORIZED
*        C - PROGRAM CONTROLLED
*        E - EXTERNAL SYMLINK
*        S - SET UID ON EXECUTION
*        S - SET GID ON EXECUTION
*        T - STICKY BIT
*      RWX - READ/WRITE/EXECUTE TRIPLETS FOR USER/GROUP/PUBLIC

*        MICROSECONDS FROM THE START OF 1900 TO THE START OF 1970
*        =  ((70*365)+17)*24*3600*1000000  =  2208988800 * 1000000
SEC70YRS DC    0D'0',FL8'2208988800E6'

         LTORG
         DS    0H
         EJECT
************************************************************
*                                                          *
*         READ AND STORE DIRECTORY ENTRY DATA              *
*                                                          *
************************************************************

         USING READHFS,R7
READHFS  DS    0H                  Process HFS directories
         LA    R0,HFSRDBUF         Point to buffer
         ST    R0,HFSBUFAD         Save the address
         LA    R0,2048             Get dynamic area size
         ST    R0,HFSBUFLN         Save buffer length
         SR    R8,R8               Initialize entry counter
         ST    R8,TAGCOUNT         Initialize tagged entry count
         LA    R3,HFSENTS          Point to first entry
         ST    R3,TOPENTAD         Show from top
         ICM   R0,15,EUIDORIG      Already a superuser?
         BZ    EUID_OK3            Yes, no need for UID change
         TM    STATUS13,$13NSPR    Allowed to be a superuser?
         BO    EUID_OK3            No, definitely not
         SR    R0,R0
         ST    R0,EUIDCRNT         Prepare for becoming a superuser
         BAS   R14,SETEUID         Set effective user id
         ICM   R15,15,HFSRETVL     Was seteuid successful?
         BNM   EUID_OK3            Yes, proceed
         OI    STATUS13,$13NSPR    No, remember not to try it again
         MVC   EUIDCRNT,EUIDORIG   Set correct current effective UID
EUID_OK3 XC    HFSTOTSZ,HFSTOTSZ   Reset size total
*        CALL  BPX1OPD,            Open HFS directory
         L     R15,FLCCVT          CVT
         L     R15,CVTCSRT-CVT(,R15) CSRTABLE
         L     R15,24(,R15)        CSR slot
         L     R15,#BPX1OPD(,R15)  Address of the service
         CALL  (15),               Open HFS directory                  +
               ($DIRNMLN,$DIRNAME,HFSRETVL,HFSRETCD,HFSRSNCD),         +
               VL,MF=(E,HFSPLIST)
         ICM   R15,15,HFSRETVL     Success?
         BNM   HFSOPEND            Yes
         MVC   MSG+2(8),=CL8'BPX1OPD '
         BAS   R14,BADBPXCL        No, load error message into heading
         B     HFSCLOSD

HFSOPEND ST    R15,HFSFLDSC        Save file descriptor
HFSRDDLP EQU   *
*        CALL  BPX1RDD,            Read HFS directory
         L     R15,FLCCVT          CVT
         L     R15,CVTCSRT-CVT(,R15) CSRTABLE
         L     R15,24(,R15)        CSR slot
         L     R15,#BPX1RDD(,R15)  Address of the service
         CALL  (15),               Read HFS directory                  +
               (HFSFLDSC,HFSBUFAD,HFSALET,HFSBUFLN,                    +
               HFSRETVL,HFSRETCD,HFSRSNCD),                            +
               VL,MF=(E,HFSPLIST)
         ICM   R2,15,HFSRETVL      Success?
         BP    HFSREDOK            Yes
         BZ    EOHFSDIR            Yes, no more directory entries
         MVC   MSG+2(8),=CL8'BPX1RDD '
         BAS   R14,BADBPXCL        No, load error message into heading
         B     EOHFSDIR            Close the directory

         USING @UNIXENT,R3
HFSREDOK LA    R4,HFSRDBUF         Point to the read buffer
HFSDIRLP CLC   0(4,R4),LASTFILE    Null entry?
         BE    EOHFSDIR            Yes, end of directory reached
         LA    R8,1(,R8)           Increment entry count
         ST    R8,UESEQNO          Set entry's internal sequence number
         XC    UEFLAGS,UEFLAGS     Clear residual data from flags
         SR    R15,R15
         ICM   R15,3,2(R4)         Get entry name length
         LA    R14,4(,R4)          Point to entry name
         STH   R15,UENMLN          Save entry name length
         LR    R1,R15              Copy name length
         LR    R6,R15              Copy name length
         LA    R0,UENAME           Point to target for name
         MVCL  R0,R14              Copy entry name
         MVC   UESERNO,0(R14)      Copy entry serial number
         LA    R6,UENAME-@UNIXENT+2+3(,R6)
         SRL   R6,2                Fullword alignment
         SLL   R6,2                Get entry length
         STH   R6,UELEN            Save it
         LA    R1,@UNIXENT(R6)     Point past this entry
         BCTR  R1,0
         BCTR  R1,0
         STH   R6,0(,R1)           Set trailing length indicator
         LH    R15,UENMLN          Get file name length
         LR    R14,R15             Copy it
         L     R6,$DIRNMLN         Get directory path name length
         AR    R14,R6              Get total path length
         ST    R14,DOUBLE          Save it
         LA    R0,$DIRNAME(R6)     Point past directory name
         LA    R1,L'$DIRNAME
         SR    R1,R6               Get length of name field after dir
         LA    R14,UENAME          Point to file name
         ICM   R15,8,HFBLANKS      Set pad character
         MVCL  R0,R14              Append file name to get whole path
         XC    STAT(ST#LEN),STAT   Clear residual data for bad call
*        CALL  BPX1LST,            Get link status
         L     R15,FLCCVT          CVT
         L     R15,CVTCSRT-CVT(,R15) CSRTABLE
         L     R15,24(,R15)        CSR slot
         L     R15,#BPX1LST(,R15)  Address of the service
         CALL  (15),               Get link status                     +
               (DOUBLE,$DIRNAME,HFSTATLN,STAT,                         +
               HFSRETVL,HFSRETCD,HFSRSNCD),                            +
               VL,MF=(E,HFSPLIST)
         TM    HFSRETVL,X'80'      File status data returned?
         BNO   HFSLSTOK            Yes
         XC    UEMODE,UEMODE       No, flag this
         MVC   UEUID,HFSRETCD      Save return code
         MVC   UEGID,HFSRSNCD      Save reason code
         B     HFUSEROK
HFSLSTOK CLI   ST_MODE,FT_SYMLINK  Symbolic link?
         BNE   HFSSTAOK            No, skip link value acquisition
         L     R15,ST_SIZE_L       Get the link value size
         LA    R0,80               Arbitrary upper limit
         CLR   R15,R0              Too big?
         BNH   HFSYMLOK            No
         LR    R15,R0              Yes, reduce to maximum
HFSYMLOK ST    R15,DOWNR           Save link buffer size
         LH    R1,UENMLN           Get the length of the entry name
         LA    R1,UENAME(R1)       Point past the entry name
         ST    R1,DOUBLE+4         Save link buffer address
*        CALL  BPX1RDL,            Read a symbolic link value
         L     R15,FLCCVT          CVT
         L     R15,CVTCSRT-CVT(,R15) CSRTABLE
         L     R15,24(,R15)        CSR slot
         L     R15,#BPX1RDL(,R15)  Address of the service
         CALL  (15),               Read a symbolic link value          +
               (DOUBLE,$DIRNAME,DOWNR,DOUBLE+4,                        +
               HFSRETVL,HFSRETCD,HFSRSNCD),                            +
               VL,MF=(E,HFSPLIST)
         ICM   R6,15,HFSRETVL      Get returned byte count
         BNP   HFSSTAOK            None
         STC   R6,UESYML           Save length of symbol value
         OI    UEFLAGS,UESYM       Flag symbol value present
         AH    R6,UENMLN           Add entry name length
         LA    R6,UENAME-@UNIXENT+2+3(,R6)
         SRL   R6,2                Fullword alignment
         SLL   R6,2                Get entry length
         STH   R6,UELEN            Save it
         LA    R1,@UNIXENT(R6)     Point past this entry
         BCTR  R1,0
         BCTR  R1,0
         STH   R6,0(,R1)           Set trailing length indicator
         TM    ST_VISIBLE,ST_EXTLINK   EXTERNAL LINK?
         BO    HFSSTAOK            Yes, do not attempt file status
*        CALL  BPX1STA,            Get file status
         L     R15,FLCCVT          CVT
         L     R15,CVTCSRT-CVT(,R15) CSRTABLE
         L     R15,24(,R15)        CSR slot
         L     R15,#BPX1STA(,R15)  Address of the service
         CALL  (15),               Get file status                     +
               (DOUBLE,$DIRNAME,HFSTATLN,STAT,                         +
               HFSRETVL,HFSRETCD,HFSRSNCD),                            +
               VL,MF=(E,HFSPLIST)
HFSSTAOK MVC   UEMODE,ST_MODE      Copy file mode
         MVC   UESERNO,ST_INO      Copy file serial number
         MVC   UEUID,ST_UID        Copy file owner's UID
         MVC   UEGID,ST_GID        Copy file owner's GID
         MVC   UESIZE,ST_SIZE      Copy file size
         MVC   UEACCDT,ST_ATIME    Copy timestamps
         MVC   UEMODDT,ST_MTIME
         MVC   UECREDT,ST_CREATETIME
         MVC   UEBLKSI,ST_BLKSIZE  Copy file block size
         MVC   UEBLOKS,ST_BLOCKS   Copy file block count
         MVC   UEVISAT,ST_VISIBLE  Copy file visible attributes
         MVC   UEVOLSR,ST_AUDITID  Copy half of RACF file id
         MVC   UEFMT,ST_FILEFMT    Copy file format
         LM    R14,R15,UESIZE      Load file size
         AL    R15,HFSTOTSZ+4      Add to total
         BC    12,HCARRYOK         No overflow
         LA    R14,1(,R14)         Carry from overflow
HCARRYOK AL    R14,HFSTOTSZ
         STM   R14,R15,HFSTOTSZ    Save new total
         MVC   UEOWNER,HFSUID0     Prepare for zero UID
         ICM   R6,15,UEUID         Is owner's UID zero?
         BZ    HFUSEROK            Yes, do not try to get RACF id
         MVC   UEOWNER,CACHEUSR
         C     R6,CACHEUID         Same UID as last check?
         BE    HFUSEROK            Yes, avoid system call
         MVC   UEOWNER,HFBLANKS    Prepare for no data returned
*        CALL  BPX1GPU,            Access user data base by UID
         L     R15,FLCCVT          CVT
         L     R15,CVTCSRT-CVT(,R15) CSRTABLE
         L     R15,24(,R15)        CSR slot
         L     R15,#BPX1GPU(,R15)  Address of the service
         CALL  (15),               Access user data base by UID        +
               (UEUID,HFSRETVL,HFSRETCD,HFSRSNCD),                     +
               VL,MF=(E,HFSPLIST)
         ICM   R15,15,HFSRETVL     Data returned?
         BNZ   HFCACHEU            Yes
         CVD   R6,DOUBLE           No
         OI    DOUBLE+7,X'0F'      Show UID number
         UNPK  UEOWNER,DOUBLE
HFUID0LP CLI   UEOWNER,C'0'        Leading zero?
         BNE   HFUSEROK            No
         MVC   UEOWNER,UEOWNER+1
         MVI   UEOWNER+7,C' '
         B     HFUID0LP
         USING GIDN,R15
HFLDUNAM MVC   CACHEUSR(0),GIDN_U_NAME  <<< Executed >>>
HFCACHEU MVC   CACHEUSR,HFBLANKS   Clear residual data
         MVC   CACHEUID,UEUID
         L     R14,GIDN_U_LEN      Get length of userid name
         LA    R0,8                Get maximum length
         CR    R14,R0              Too long?
         BNH   *+6                 No
         LR    R14,R0              Yes, reduce to maximum
         BCTR  R14,0               Decrement for execute
         EX    R14,HFLDUNAM        Load the RACF userid
         MVC   UEOWNER,CACHEUSR
         DROP  R15                 GIDN
HFUSEROK SR    R0,R0
         ICM   R0,3,0(R4)          Get buffer entry length
         ALR   R4,R0               Point to next returned entry
         AH    R3,UELEN            Point to next internal entry
         C     R3,MAXENTAD         Filled up internal storage?
         BH    UNIXFULL            Yes, go handle it
         BCT   R2,HFSDIRLP         Process next directory entry
         B     HFSRDDLP            Get next buffer of entries

UNIXFULL MVI   MSG,95              Storage full - read terminated

EOHFSDIR L     R6,$DIRNMLN         Get directory path name length
         LA    R14,$DIRNAME(R6)    Point past directory name
         LA    R15,L'$DIRNAME
         SR    R15,R6              Get length of name field after dir
         SR    R1,R1               Set source length
         SR    R0,R0               Set source address (not needed)
         ICM   R1,8,HFBLANKS       Set pad character
         MVCL  R14,R0              Clear file name from directory path
*        CALL  BPX1CLD,            Close HFS directory
         L     R15,FLCCVT          CVT
         L     R15,CVTCSRT-CVT(,R15) CSRTABLE
         L     R15,24(,R15)        CSR slot
         L     R15,#BPX1CLD(,R15)  Address of the service
         CALL  (15),               Close HFS directory                 +
               (HFSFLDSC,HFSRETVL,HFSRETCD,HFSRSNCD),                  +
               VL,MF=(E,HFSPLIST)
         ICM   R15,15,HFSRETVL     Success?
         BNM   HFSCLOSD            Yes
         MVC   MSG+2(8),=CL8'BPX1CLD '
         BAS   R14,BADBPXCL        No, load error message into heading
HFSCLOSD ST    R8,ENTRYCNT         Save count of entries in list
         MVC   0(10,R3),LASTENT    Denote end of entry list
         ST    R3,LSTENTAD         Save address of last entry
         LA    R8,1(,R8)           Get list row count
         ST    R8,UESEQNO          Save it
         CLC   EUIDCRNT,EUIDORIG   Was the effective UID changed?
         BE    TOPENTRY            No, so no need to change it back
         MVC   EUIDCRNT,EUIDORIG   Yes, change it back
         BAS   R14,SETEUID         Set effective user id
         B     TOPENTRY            Return to mainline

         DROP  R7,R3               READHFS, @UNIXENT

HFSALET  DC    F'0'                All activity in this address space
HFSUID0  DC    CL8'*SUPER* '

         LTORG
         DS    0H
         EJECT
************************************************************
*                                                          *
*         DIRECTORY DISPLAY SUBCOMMAND TABLE               *
*                                                          *
************************************************************

HFSCMDTB DS    0H                 Entries must be in collating sequence
         DC    CL8'+       '
         B     HFSDNCMD
         DC    CL8'-       '
         B     HFSUPCMD
         DC    CL8'=X      '
         B     HFSEXIT
         DC    CL8'B       '
         B     HFSPFCMD
         DC    CL8'BOT     '
         B     HFSBOTOM
         DC    CL8'BOTTOM  '
         B     HFSBOTOM
         DC    CL8'BROWSE  '
         B     HFSPFCMD
         DC    CL8'CAN     '
         B     HFSCAN
         DC    CL8'CANCEL  '
         B     HFSCAN
         DC    CL8'DOWN    '
         B     HFSDNCMD
         DC    CL8'E       '
         B     HFSPFCMD
         DC    CL8'EDIT    '
         B     HFSPFCMD
         DC    CL8'END     '
         B     HFSEND
         DC    CL8'EXIT    '
         B     HFSEXIT
         DC    CL8'F       '
         B     HFSEARCH
         DC    CL8'FIND    '
         B     HFSEARCH
         DC    CL8'IFIND   '
         B     HFINDTAG
         DC    CL8'L       '
         B     HFSLOC
         DC    CL8'LIST    '
         B     HFSLOC
         DC    CL8'LOC     '
         B     HFSLOC
         DC    CL8'LOCATE  '
         B     HFSLOC
         DC    CL8'REF     '
         B     HFSRFRSH
         DC    CL8'REFRESH '
         B     HFSRFRSH
         DC    CL8'RES     '
         B     HTAGREST
         DC    CL8'RESET   '
         B     HTAGREST
         DC    CL8'RETURN  '
         B     HFSEXIT
         DC    CL8'RFIND   '
         B     HFINDTAG
         DC    CL8'S       '
         B     HFSSEL
         DC    CL8'SEARCH  '
         B     HFSEARCH
         DC    CL8'SEL     '
         B     HFSSEL
         DC    CL8'SELECT  '
         B     HFSSEL
         DC    CL8'SORT    '
         B     HFSSORT
         DC    CL8'TAGFLIP '
         B     HTAGFLIP
         DC    CL8'TF      '
         B     HTAGFLIP
         DC    CL8'TOP     '
         B     HFSTOP
         DC    CL8'UP      '
         B     HFSUPCMD
         DC    H'-1'               End of table


         DROP  R11,R10,R13         REVUNIX, @HFSDYN
         TITLE '  R E V U N I X   -   H F S   " B S A M "  '
************************************************************
*                                                          *
*         EMULATE DCB READ AND CHECK FOR HFS FILE I/O      *
*                                                          *
************************************************************

         USING USSREAD,R11
USSREAD  DS    0H                  Pointed to by DCBREAD
         STM   R14,R12,12(R13)     Save registers
         LR    R11,R15             Set base
         LA    R15,CALLSAVE        Point to new save area
         ST    R13,4(,R15)         Chain save areas
         ST    R15,8(,R13)
         LR    R13,R15             Point to new save area
         L     R4,8(,R1)           Point to "DCB"
         MVC   12(8,R4),4(R4)      Save pre-read offset for note
         USING IHADCB,R4
         LA    R5,12(,R1)          Point to block pointer
*        CALL  BPX1RED,            Read HFS file
         L     R15,FLCCVT          CVT
         L     R15,CVTCSRT-CVT(,R15) CSRTABLE
         L     R15,24(,R15)        CSR slot
         L     R15,#BPX1RED(,R15)  Address of the service
         CALL  (15),               Read HFS file                       +
               ((R4),(R5),ZEROALET,UREADCNT,                           +
               URETVAL,URETCODE,URSNCODE),                             +
               VL,MF=(E,MSG+100)
         ICM   R1,15,URETVAL
         BM    USSRDBAD            Read failure - signal error
         L     R15,UREADCNT        Get requested read byte count
         SR    R15,R1              Subtract actual read byte count
         ST    R15,PHONYIOB+12     Save "residual count"
         LTR   R15,R1              Copy bytes read
         BZ    USSEOF              Nothing read - signal end-of-file
         A     R1,8(,R4)           Adjust current offset
         ST    R1,8(,R4)
         CLI   UREADCNT+2,1        Is read count more than 256?
         BH    USSREADX            Yes, probably 4096 so skip NL scan
         TM    STATUS9,$9F80       Card images with binary data?
         BO    USSREADX            Yes, so skip NL scan
         BCTR  R15,0               Decrement for execute
         L     R14,0(,R5)          Point to data just read
         TM    STATUS8,$8_A        Was ASCII text explicilty requested?
         BO    USSBINOK            Yes, skip binary/text check
         ICM   R0,15,COUNT         Reading first record of file?
         BNZ   USSBINOK            No, file type already decided
         ICM   R0,15,KOUNT         Very first read of the file?
         BNZ   USSBINOK            No, file type already decided
         EX    R15,USSNDSCN        Any non-displayable data in record?
         BZ    USSSEQOK            No, check for new line
         OI    STATUS9,$9F80       Yes, binary file so skip NL scan
         B     USSREADX
USSSEQOK ST    R0,MAXPOINT         Use sequential access and
         NI    STATUS2,255-$2FAST  Disable "fastpath"
USSBINOK TM    STATUS8,$8_A        Was ASCII text explicilty requested?
         BNO   UNIXEBCD            No, look for EBCDIC new line
         EX    R15,USSLFSCN        Look for ASCII line feed (LF)
         BZ    USSREADX            None found so show maximum length
         LR    R15,R1              Point to ASCII line feed
         SR    R1,R14              Get data length of this record
         BNP   UNIXNOCR            No data before line feed
         BCTR  R15,0               Point to character before line feed
         CLI   0(R15),X'0D'        Carriage return in ASCII "CRLF"?
         BNE   UNIXNOCR            No, proceed as normal
         BCTR  R1,0                Yes, throw away the CR with the LF
         L     R14,UREADCNT        Get requested read byte count
         SR    R14,R1              Subtract actual read byte count
         ST    R14,PHONYIOB+12     Save "residual count"
         LA    R14,2(,R1)          Get bytes processed (include CRLF)
         B     USSLENOK            Length now determined
UNIXEBCD EX    R15,USSNLSCN        Look for new line (NL) character
         BZ    USSREADX            None found so show maximum length
         SR    R1,R14              Get data length of this record
UNIXNOCR L     R14,UREADCNT        Get requested read byte count
         SR    R14,R1              Subtract actual read byte count
         ST    R14,PHONYIOB+12     Save "residual count"
         LA    R14,1(,R1)          Get bytes processed (include NL)
USSLENOK A     R14,16(,R4)         Add to pre-read offset
         C     R14,8(,R4)          Already at desired offset?
         BE    USSREADX            Yes, no need for seek
         ST    R14,8(,R4)          Set desired post-read offset
         LA    R5,4(,R4)           Point to requested offset
*        CALL  BPX1LSK,            Change the HFS file offset
         L     R15,FLCCVT          CVT
         L     R15,CVTCSRT-CVT(,R15) CSRTABLE
         L     R15,24(,R15)        CSR slot
         L     R15,#BPX1LSK(,R15)  Address of the service
         CALL  (15),               Change the HFS file offset          +
               ((R4),(R5),REFPOINT,                                    +
               URETVAL,URETCODE,URSNCODE),                             +
               VL,MF=(E,MSG+100)
         ICM   R1,15,URETVAL
         BM    USSPTBAD            Seek failure - signal error
         B     USSREADX
USSNDSCN TRT   0(0,R14),USSNDTAB   <<< Executed >>>
USSNLSCN TRT   0(0,R14),USSNLTAB   <<< Executed >>>
USSLFSCN TRT   0(0,R14),USSLFTAB   <<< Executed >>>

USSRDBAD MVI   SYNADSW,X'FF'       Flag I/O error
         MVI   SYNADMSG,C'*'
         MVC   SYNADMSG+1(77),SYNADMSG
         MVC   SYNADMSG+18(21),=CL21' BPX1RED FAILED - RC='
         UNPK  SYNADMSG+39(9),URETCODE(5)
         TR    SYNADMSG+39(8),USSHEX-C'0'
         MVC   SYNADMSG+47(5),=CL5' RSN='
         UNPK  SYNADMSG+52(9),URSNCODE(5)
         TR    SYNADMSG+52(8),USSHEX-C'0'
         MVI   SYNADMSG+60,C' '
         MVI   DCBSYNAD,X'FF'      Flag error pending for check

USSREADX L     R13,4(,R13)         Point to caller's save area
         LM    R14,R12,12(R13)     Restore registers
         BR    R14                 Return to caller

USSEOF   ICM   R15,7,DCBEODA       Get end of data routine address
         L     R13,4(,R13)         Point to caller's save area
         L     R14,12(,R13)        Restore return address
         LM    R0,R12,20(R13)      Restore other registers
         BR    R15                 Invoke end of data "DCB exit"

         DROP  R11,R4              USSREAD, IHADCB

USSCHECK DS    0H                  Pointed to by DCBCHECK
         L     R1,8(,R1)           Point to DCB
         USING IHADCB,R1
         OC    SYNADSW,DCBSYNAD    Propagate any pending I/O error
         MVI   DCBSYNAD,0          Any pending condition now cleared
         BR    R14                 I/o synchronised
         DROP  R1                  IHADCB


************************************************************
*                                                          *
*         EMULATE DCB NOTE AND POINT FOR HFS FILE I/O      *
*                                                          *
************************************************************

         USING USSPOINT,R15
USSPOINT DS    0H                  Pointed to be DCBPOINT
         B     USSNOTE             Note entry point
         DROP  R15                 USSPOINT
         USING USSPOINT,R11
         STM   R14,R12,12(R13)     Save registers
         LR    R11,R15             Set base
         LA    R15,CALLSAVE        Point to new save area
         ST    R13,4(,R15)         Chain save areas
         ST    R15,8(,R13)
         LR    R13,R15             Point to new save area
         LR    R4,R1               Point to "DCB"
         USING IHADCB,R4
         LR    R1,R0               Point to requested offset
         MVC   16(4,R4),0(R1)      Save requested offset
         LA    R5,12(,R4)          Point to requested offset
*        CALL  BPX1LSK,            Change the HFS file offset
         L     R15,FLCCVT          CVT
         L     R15,CVTCSRT-CVT(,R15) CSRTABLE
         L     R15,24(,R15)        CSR slot
         L     R15,#BPX1LSK(,R15)  Address of the service
         CALL  (15),               Change the HFS file offset          +
               ((R4),(R5),REFPOINT,                                    +
               URETVAL,URETCODE,URSNCODE),                             +
               VL,MF=(E,MSG+100)
         ICM   R1,15,URETVAL
         BM    USSPTBAD            Seek failure - signal error
         MVC   4(8,R4),0(R5)       Update current offset
         B     USSPNTX

USSPTBAD MVI   SYNADSW,X'FF'       Flag I/O error
         MVI   SYNADMSG,C'*'
         MVC   SYNADMSG+1(77),SYNADMSG
         MVC   SYNADMSG+18(21),=CL21' BPX1LSK FAILED - RC='
         UNPK  SYNADMSG+39(9),URETCODE(5)
         TR    SYNADMSG+39(8),USSHEX-C'0'
         MVC   SYNADMSG+47(5),=CL5' RSN='
         UNPK  SYNADMSG+52(9),URSNCODE(5)
         TR    SYNADMSG+52(8),USSHEX-C'0'
         MVI   SYNADMSG+60,C' '
         MVI   DCBSYNAD,X'FF'      Flag error pending for check
         MVC   12(8,R4),4(R4)      Restore saved offset

USSPNTX  L     R13,4(,R13)         Point to caller's save area
         LM    R14,R12,12(R13)     Restore registers
         BR    R14                 Return to caller

         DROP  R11,R4              USSPOINT, IHADCB

USSNOTE  L     R1,16(,R1)          Load saved pre-read file offset
         BR    R14                 Return to caller

         LTORG
ZEROALET DC    F'0'                Alet for current address space
REFPOINT DC    A(SEEK_SET)         Lseek reference point setting
USSNLTAB DC    21AL1(0),AL1(21),234AL1(0)
USSLFTAB DC    10AL1(0),AL1(10),245AL1(0)
USSNDTAB DC    21AL1(*-USSNDTAB),AL1(0),42AL1(*-USSNDTAB)
         DC    191AL1(0),AL1(255)
USSHEX   DC    C'0123456789ABCDEF' Hexadecimal digit translate table

         DC    0D'0'               End of CSECT
         TITLE '  R E V U N I X   -   D Y N A M I C   A R E A  '
@HFSDYN  DSECT
$HFSORT  EQU   X'80'               Explicit SORT command issued
$HFSEND  EQU   X'40'               ENDed to parent directory
         DS    18F                 Working save area
UNIXVOL  DS    D                   Volume serial save area
EUIDORIG DS    F                   Original effective UID
EUIDCRNT DS    F                   Current effective UID
HFSTOTSZ DS    D                   Total size of all entries
TOPENTAD DS    F                   Top entry address save area
LSTENTAD DS    F                   Last entry address save area
CURENTAD DS    F                   Current entry being processed
MAXENTAD DS    F                   Top usable address of HFSENTS
ENTRYCNT DS    F                   Total number of entries in list
HFSFLDSC DS    F                   File descriptor
HFSRETVL DS    F                   Return value
HFSRETCD DS    F                   Return code
HFSRSNCD DS    F                   Reason code
HFSBUFAD DS    F                   Read buffer address
HFSBUFLN DS    F                   Read buffer length
HFSPLIST DS    7F                  Call parameter list
CACHEUID DS    F                   UID cached from last BPX1GPU call
CACHEUSR DS    CL8                 User cached from last BPX1GPU call
MAXFNLEN DS    H                   Maximum file name length
SELENTNM DS    H,CL256             User selected entry
$DIRNMLN DS    F                   Current directory name length
$PATHLEN DS    F         \_______/ Complete path name length \__path
$DIRNAME DS    CL1024    /       \ Current directory name    /  spec
         BPXYSTAT DSECT=NO         File status area
         ORG   ST_MODE
         BPXYMODE DSECT=NO         File mode flags
         ORG
         BPXYFTYP DSECT=NO         File type and format equates
HFSRDBUF DS    256D                2k read buffer
         ORG   HFSRDBUF            Directory search working storage
HSCHTCNT DS    F                   Highlighted file count - before
HSCHFCNT DS    F                   Highlighted file count - after
HSCHMDON DS    F                   Searched file entry count
HSCHPCT1 DS    F                   Search % done before current file
HSCHPCT2 DS    F                   Search % done after current file
HSCHBRTM DS    F                   Time of last progress bar update
         DS    0D                  Rest are multiples of 8 bytes
HSCHMTCH DS    CL8                 Latest matched file name
HSCHLINE DS    CL160               Message work area
         ORG
HFSENTS  DS    0D                  In-core entry list starts here
$HFSDYNL EQU   128*1024            Total size of @HFSDYN

@UNIXENT DSECT
UELEN    DS    H                   Length of entire internal entry
UEFLAGS  DS    XL1                 Internal flags
UETAG    EQU   X'80'               Entry is tagged
UESYM    EQU   X'40'               Entry has symbol value after name
UESYML   DS    XL1                 Length of the symbol value
UESEQNO  DS    XL4                 Internal entry sequence number
UESERNO  DS    XL4                 Directory entry serial number
UEMODE   DS    XL4                 File mode
UEUID    DS    XL4                 UID of file owner
UEGID    DS    XL4                 GID of file owner
UEOWNER  DS    CL8                 RACF userid of owner
UEBLKSI  DS    XL4                 Block size
UEBLOKS  DS    XL4                 Block count
UESIZE   DS    0XL8                Byte count
UESIZEH  DS    XL4
UESIZEL  DS    XL4
UEVOLSR  DS    XL8                 First half of RACF audit file id
UECREDT  DS    XL4                 Creation timestamp
UEMODDT  DS    XL4                 Change timestamp
UEACCDT  DS    XL4                 Access timestamp
UEVISAT  DS    XL1                 Visible attributes
UEFMT    DS    XL1                 File format
UENMLN   DS    H                   Length of file name
UENAME   DS    0C                  File name
*        DS    H                   Length of entire internal entry

         BPXYGIDN DSECT=YES
         BPXYOPNF DSECT=YES
         BPXYSEEK DSECT=YES

*        System control offsets to callable services
#BPX1ACC EQU     52                access
#BPX1ACK EQU    972                auth_check_rsrc_np
#BPX1ACP EQU    508                accept
#BPX1AIO EQU    988                asyncio
#BPX1ALR EQU    224                alarm
#BPX1ANR EQU   1060                accept_and_recv
#BPX1ASP EQU   1088                aio_suspend
#BPX1ATM EQU    668                attach_execmvs
#BPX1ATX EQU    664                attach_exec
#BPX1BND EQU    512                bind
#BPX1CCA EQU    480                cond_cancel
#BPX1CCS EQU   1012                console_np
#BPX1CHA EQU     84                chaudit
#BPX1CHD EQU     56                chdir
#BPX1CHM EQU     60                chmod
#BPX1CHO EQU     64                chown
#BPX1CHP EQU    764                chpriority
#BPX1CHR EQU    500                chattr
#BPX1CID EQU    968                convert_id_np
#BPX1CLD EQU     68                closedir
#BPX1CLO EQU     72                close
#BPX1CON EQU    516                connect
#BPX1CPL EQU   1132                __cpl
#BPX1CPO EQU    484                cond_post
#BPX1CRT EQU    872                chroot
#BPX1CSE EQU    488                cond_setup
#BPX1CTW EQU    492                cond_timed_wait
#BPX1CWA EQU    496                cond_wait
#BPX1DEL EQU    888                deletehfs
#BPX1DSD EQU   1124                sw_signaldelv
#BPX1ENV EQU    960                oe_env_np
#BPX1EXC EQU    228                exec
#BPX1EXI EQU    232                _exit
#BPX1EXM EQU    236                execmvs
#BPX1EXT EQU    200                extlink_np
#BPX1FAI EQU   1168                FreeAddrInfo
#BPX1FCA EQU    140                fchaudit
#BPX1FCD EQU    852                fchdir
#BPX1FCM EQU     88                fchmod
#BPX1FCO EQU     92                fchown
#BPX1FCR EQU    504                fchattr
#BPX1FCT EQU     96                fcntl
#BPX1FPC EQU    100                fpathconf
#BPX1FRK EQU    240                fork
#BPX1FST EQU    104                fstat
#BPX1FSY EQU    108                fsync
#BPX1FTR EQU    112                ftruncate
#BPX1FTV EQU    848                FstatVfs
#BPX1GAI EQU   1164                GetAddrInfo
#BPX1GCL EQU   1024                getclientid
#BPX1GCW EQU    116                getcwd
#BPX1GEG EQU    244                getegid
#BPX1GEP EQU    860                getpgid
#BPX1GES EQU    864                getsid
#BPX1GET EQU    736                w_getipc
#BPX1GEU EQU    248                geteuid
#BPX1GGE EQU    772                getgrent
#BPX1GGI EQU    252                getgrgid
#BPX1GGN EQU    256                getgrnam
#BPX1GGR EQU    260                getgroups
#BPX1GHA EQU   1160                gethostbyaddr
#BPX1GHN EQU   1156                gethostbyname
#BPX1GID EQU    264                getgid
#BPX1GIV EQU   1028                givesocket
#BPX1GLG EQU    268                getlogin
#BPX1GMN EQU     76                w_getmntent
#BPX1GNI EQU   1172                GetNameInfo
#BPX1GNM EQU    524                getpeername
#BPX1GPE EQU    776                getpwent
#BPX1GPG EQU    272                getpgrp
#BPX1GPI EQU    276                getpid
#BPX1GPN EQU    280                getpwnam
#BPX1GPP EQU    284                getppid
#BPX1GPS EQU    428                w_getpsent
#BPX1GPT EQU    916                grantpt
#BPX1GPU EQU    288                getpwuid
#BPX1GPY EQU    744                getpriority
#BPX1GRL EQU    820                getrlimit
#BPX1GRU EQU    824                getrusage
#BPX1GTH EQU   1056                __getthent
#BPX1GTR EQU    752                getitimer
#BPX1GUG EQU    292                getugrps
#BPX1GUI EQU    296                getuid
#BPX1GWD EQU    936                getwd
#BPX1HST EQU    520                gethostid
#BPX1IOC EQU    120                w_ioctl
#BPX1IPT EQU    396                MvsIptAffinity
#BPX1ITY EQU     12                isatty
#BPX1KIL EQU    308                kill
#BPX1LCO EQU    832                lchown
#BPX1LNK EQU    124                link
#BPX1LOD EQU    880                loadhfs
#BPX1LSK EQU    128                lseek
#BPX1LSN EQU    532                listen
#BPX1LST EQU    132                lstat
#BPX1MAT EQU    720                shmat
#BPX1MCT EQU    724                shmctl
#BPX1MDT EQU    728                shmdt
#BPX1MGT EQU    732                shmget
#BPX1MKD EQU    136                mkdir
#BPX1MKN EQU    144                mknod
#BPX1MMI EQU   1136                __map_init
#BPX1MMP EQU    796                mmap
#BPX1MMS EQU   1140                __map_service
#BPX1MNT EQU    148                mount
#BPX1MP  EQU    688                MVSpause
#BPX1MPC EQU    408                mvsprocclp
#BPX1MPI EQU    680                MVSpauseInit
#BPX1MPR EQU    800                mprotect
#BPX1MSD EQU    336                mvsunsigsetup
#BPX1MSS EQU    312                mvssigsetup
#BPX1MSY EQU    804                msync
#BPX1MUN EQU    808                munmap
#BPX1NIC EQU    748                nice
#BPX1OPD EQU    152                opendir
#BPX1OPN EQU    156                open
#BPX1OPT EQU    528                getsockopt
#BPX1OSE EQU   1100                __osenv
#BPX1PAF EQU   1072                __pid_affinity
#BPX1PAS EQU    316                pause
#BPX1PCF EQU    160                pathconf
#BPX1PCT EQU    768                pfsctl
#BPX1PIO EQU    984                w_pioctl
#BPX1PIP EQU    164                pipe
#BPX1POL EQU    932                poll
#BPX1PQG EQU   1152                pthread_quiesce_and_get_np
#BPX1PSI EQU    460                pthread_setintr
#BPX1PST EQU    472                pthread_setintrtype
#BPX1PTB EQU    448                pthread_cancel
#BPX1PTC EQU    432                pthread_create
#BPX1PTD EQU    444                pthread_detach
#BPX1PTI EQU    476                pthread_testintr
#BPX1PTJ EQU    440                pthread_join
#BPX1PTK EQU    464                pthread_kill
#BPX1PTQ EQU    412                pthread_quiesc
#BPX1PTR EQU    320                ptrace
#BPX1PTS EQU    452                pthread_self
#BPX1PTT EQU   1016                pthread_tag_np
#BPX1PTX EQU    436                pthread_xandg
#BPX1PWD EQU    788                __passwd
#BPX1QCT EQU    692                msgctl
#BPX1QDB EQU    948                querydub
#BPX1QGT EQU    696                msgget
#BPX1QRC EQU    700                msgrcv
#BPX1QSE EQU    388                quiesce
#BPX1QSN EQU    704                msgsnd
#BPX1RCV EQU    540                recv
#BPX1RDD EQU    168                readdir
#BPX1RDL EQU    172                readlink
#BPX1RDV EQU    536                readv
#BPX1RDX EQU    940                read_extlink
#BPX1RD2 EQU    856                readdir2
#BPX1RED EQU    176                read
#BPX1REN EQU    180                rename
#BPX1RFM EQU    544                recvfrom
#BPX1RMD EQU    188                rmdir
#BPX1RMG EQU      8                resource
#BPX1RMS EQU    548                recvmsg
#BPX1RPH EQU    884                realpath
#BPX1RW  EQU   1108                Pread() and Pwrite()
#BPX1RWD EQU    184                rewinddir
#BPX1SA2 EQU   1084                __sigactionset
#BPX1SCT EQU    708                semctl
#BPX1SDD EQU    300                set_dub_default
#BPX1SEC EQU   1044                create new security environment
#BPX1SEG EQU    424                setegid
#BPX1SEL EQU    552                select
#BPX1SEU EQU    420                seteuid
#BPX1SF  EQU   1064                send_file PC-only
#BPX1SGE EQU    780                setgrent
#BPX1SGI EQU    328                setgid
#BPX1SGQ EQU   1104                sigqueue
#BPX1SGR EQU    792                setgroups
#BPX1SGT EQU    712                semget
#BPX1SHT EQU    572                shutdown
#BPX1SIA EQU    324                sigaction
#BPX1SIN EQU   1004                server_init
#BPX1SIP EQU    340                sigpending
#BPX1SLK EQU   1068                __shm_lock
#BPX1SLP EQU    344                sleep
#BPX1SMC EQU   1112                __smc
#BPX1SMF EQU   1036                __smf_record
#BPX1SMS EQU    560                sendmsg
#BPX1SND EQU    556                send
#BPX1SOC EQU    576                socket_pair
#BPX1SOP EQU    716                semop
#BPX1SPB EQU    416                sigputback
#BPX1SPE EQU    784                setpwent
#BPX1SPG EQU    348                setpgid
#BPX1SPM EQU    352                sigprocmask
#BPX1SPN EQU    760                spawn
#BPX1SPR EQU    568                setpeer
#BPX1SPW EQU   1008                server_pwu
#BPX1SPY EQU    740                setpriority
#BPX1SRG EQU    896                setregid
#BPX1SRL EQU    816                setrlimit
#BPX1SRU EQU    892                setreuid
#BPX1SRX EQU   1080                srx_np
#BPX1SSI EQU    356                setsid
#BPX1SSU EQU    360                sigsuspend
#BPX1STA EQU    192                stat
#BPX1STE EQU   1076                set_timer_event
#BPX1STF EQU     80                w_statfs
#BPX1STL EQU    684                set_limits
#BPX1STO EQU    564                sendto
#BPX1STR EQU    756                setitimer
#BPX1STV EQU    844                StatVfs
#BPX1STW EQU   1096                sigtimedwait
#BPX1SUI EQU    364                setuid
#BPX1SWT EQU    468                sigwait
#BPX1SYC EQU    368                sysconf
#BPX1SYM EQU    196                symlink
#BPX1SYN EQU    868                sync
#BPX1TAF EQU   1148                MvsThreadAffinity
#BPX1TAK EQU   1032                takesocket
#BPX1TDR EQU     24                tcdrain
#BPX1TFH EQU     20                tcflush
#BPX1TFW EQU     28                tcflow
#BPX1TGA EQU     32                tcgetattr
#BPX1TGC EQU    900                tcgetcp
#BPX1TGP EQU     36                tcgetpgrp
#BPX1TGS EQU    912                tcgetsid
#BPX1TIM EQU    372                times
#BPX1TLS EQU    964                tsk_lvl_sec_np
#BPX1TRU EQU    828                truncate
#BPX1TSA EQU     40                tcsetattr
#BPX1TSB EQU     44                tcsendbreak
#BPX1TSC EQU    904                tcsetcp
#BPX1TSP EQU     48                tcsetpgrp
#BPX1TST EQU    908                tcsettables
#BPX1TYN EQU     16                ttyname
#BPX1UMK EQU    204                umask
#BPX1UMT EQU    208                umount
#BPX1UNA EQU    376                uname
#BPX1UNL EQU    212                unlink
#BPX1UPT EQU    920                unlockpt
#BPX1UQS EQU    392                unquiesce
#BPX1UTI EQU    216                utime
#BPX1VAC EQU    944                v_access
#BPX1VCR EQU    620                v_create
#BPX1VEX EQU    876                v_export
#BPX1VGA EQU    632                v_getattr
#BPX1VGT EQU    596                v_get
#BPX1VLK EQU    604                v_lookup
#BPX1VLN EQU    640                v_link
#BPX1VLO EQU    660                v_lockctl
#BPX1VMD EQU    624                v_mkdir
#BPX1VPC EQU   1040                v_pathconf
#BPX1VRA EQU    616                v_readlink
#BPX1VRD EQU    612                v_readdir
#BPX1VRE EQU    644                v_rmdir
#BPX1VRG EQU    584                v_reg
#BPX1VRL EQU    600                v_rel
#BPX1VRM EQU    648                v_remove
#BPX1VRN EQU    652                v_rename
#BPX1VRP EQU    588                v_rpn
#BPX1VRW EQU    608                v_rdwr
#BPX1VSA EQU    636                v_settatr
#BPX1VSF EQU    656                v_fstatfs
#BPX1VSY EQU    628                v_symlink
#BPX1WAT EQU    380                wait
#BPX1WLM EQU   1048                __wlm
#BPX1WRT EQU    220                write
#BPX1WRV EQU    580                writev
#BPX1WTE EQU    840                waitid/wait3
#BPX2ITY EQU    928                isatty2
#BPX2MNT EQU   1128                __mount
#BPX2OPN EQU   1052                openstat
#BPX2RMS EQU    976                recvmsg2
#BPX2SMS EQU    980                sendmsg2
#BPX2TYN EQU    924                ttyname2
         TITLE '  R E V P D S E  '
**********************************************************************
*                                                          *         *
*         PDSE PROGRAM OBJECT DIRECTORY HANDLER            *  GP@HC  *
*                                                          * 01/2001 *
**********************************************************************
*                                                                    *
* Registers on entry: R9 -> @DATA                                    *
*                     R13-> Save area                                *
*                     R14-> Return address                           *
*                     R15-> REVPDSE                                  *
*                                                                    *
* During processing:  R13-> @PO#DYN  (local GETMAINed area)          *
*                                                                    *
* Return codes:       R15 = 0  Processing complete                   *
*                                                                    *
**********************************************************************

REVPDSE  CSECT
         B     @PDSE-*(,R15)
@PDSELBL EQU   *+1,8
         DC    AL1(7),CL9'REVPDSE'
@PDSE    STM   R14,R12,12(R13)     Save registers
         LR    R11,R15             Base registers
         LA    R15,1
         LA    R10,4095(R15,R11)
         USING (REVPDSE,OBJFRMAT),R11,R10
OBREFRSH LR    R4,R13              Save save area pointer
         LA    R2,OBJGMLIM         Point to bounds of GETMAIN length
         LA    R3,DOUBLE           Point to results area
         XC    GMVUW(GMVCL),GMVUW
         GETMAIN VC,LA=(R2),A=(R3),MF=(E,GMVUW)
         LTR   R15,R15             Did GETMAIN work?
         BZ    OBUSEDYN            Yes, proceed
         MVI   MSG,57              Region full - directory read ended
         L     R15,=A(REVMSGS)
         BASR  R14,R15             Fetch message text
         LA    R1,MSG+2            Point to error message
         LH    R0,MSG              Get error message length
         TPUT  (1),(0),R           Display message
         LM    R14,R12,12(R13)     Restore registers
         LA    R15,20              Set return code
         BR    R14                 Return
OBUSEDYN L     R12,DOUBLE+4        Get length of GETMAINed area
         L     R13,DOUBLE          Get address of GETMAINed area
         USING @PO#DYN,R13
         ST    R13,8(,R4)
         ST    R4,4(,R13)          Chain save areas
         STM   R12,R13,OBFMREGS    Save FREEMAIN values
         ALR   R12,R13             Get address above GETMAINed area
         LA    R0,512              Take a punt
         SR    R12,R0
         ST    R12,MAXOBJAD        Save highest usable address
         NI    MODE,255-MD_EREP    Disable EREP formatting

         MVC   OBJDCBD,OBJDCBS
         MVC   OBJDCBD+DCBDDNAM-IHADCB(8),$DDNAME
         MVI   OPEND,X'80'         Open PDSE
         OPEN (OBJDCBD,INPUT),MF=(E,OPEND)
         MVC   OBJWRKBF(ISITMGDL),ISITMGDT
         USING ISM,OBJWRKBF
         ISITMGD DCB=OBJDCBD,DATATYPE=YES,MF=(E,OBJWRKBF)
         TM    ISMOFLG3,ISMDTPGM   Program object library?
         BZ    NOPGMOBJ            No, data RECFM=U PDSE or never used
         OI    STATUS9,$9PGMOBJ    Yes, flag this

         L     R7,RDOBJADR         Point to directory processor
         BR    R7                  Process directory information

NOPGMOBJ MVI   CLOSED,X'80'        Close BPAM DCB
         CLOSE (OBJDCBD),MF=(E,CLOSED)
         LM    R0,R1,OBFMREGS      Load FREEMAIN values
         L     R13,4(,R13)         Point to caller's save area
         FREEMAIN R,LV=(0),A=(1)   Free @PO#DYN
         L     R15,=A(REVPDS)      Point to correct routine
         ST    R15,16(,R13)        Save address in r15 slot
         LM    R14,R12,12(R13)     Restore registers
         BR    R15                 Transfer to correct routine

TOPOBJCT OI    STATUS,STPODIR      Flag directory list mode
         TM    STATUS4,$4ATTN      Attention interrupt?
         BO    FINDOBJ             Yes, don't perform sort
         TM    STATUS3,$3DATE
         BO    OSRTDATE
         TM    STATUS3,$3SIZE
         BO    OSRTSIZE
         TM    STATUS3,$3TTR
         BO    OSRTTTR
         TM    STATUS3,$3USER
         BO    OSRTUSER
         TM    STATUS3,$3SSI
         BO    OSRTSSI
         TM    STATUS3,$3PDSE
         BNO   FINDOBJ
         TM    OBJFLAGS,OESREAL
         BO    OSRTREAL
         TM    OBJFLAGS,OESAUTH
         BO    OSRTAUTH
         TM    OBJFLAGS,OESMODE
         BO    OSRTMODE
         TM    OBJFLAGS,OESATTR
         BO    OSRTATTR
         TM    OBJFLAGS,OESVRSN
         BO    OSRTVRSN
         TM    OBJFLAGS,OESEPA
         BO    OSRTEPA
FINDOBJ  LA    R3,OBJENTS          Point to first entry
         USING @POBJENT,R3
         OC    SELOBJNM,SELOBJNM   Non-zero member name to locate?
         BZ    THISOBJ             No, go to top
TRYOBJNM LA    R0,SELOBJNM+2       Point to requested name
         LH    R1,SELOBJNM         Get length of requested name
         LA    R14,OENAME          Point to entry's name
         LH    R15,OENMLN          Get length of entry's name
         ICM   R15,8,POBLANKS      Set pad character
         CLCL  R0,R14              Up to required member?
         BE    THISOBJ             Yes, found it
         BH    NEXTOBJ             No, no there yet
         TM    STATUS3,$3SORT      Entries in collating sequence?
         BZ    PREVOBJ             Yes, passed it, so backup one
NEXTOBJ  C     R3,LSTOBJAD         No, reached end of entries?
         BE    NOOBHERE            Yes, stop scanning
         AH    R3,OELEN            Point to next entry
         B     TRYOBJNM
NOOBHERE TM    STATUS3,$3SORT      Entries in collating sequence?
         BZ    THISOBJ             No message needed
         TM    STATUS3,$3USER      Entries in user/job name sequence?
         BO    OBLOCUSR            Yes
         MVI   MSG,76              Exact name not found
         B     SAMEOBJS
SAMEOBJP ST    R4,CUROBJAD         Point to processed member
SAMEOBJS L     R3,TOPOBJAD         Restore entry pointer
         B     THISOBJ             Reshow without movement
OBLOCUSR OC    SELOBJNM+2(8),POBLANKS  Fold to upper case
         LA    R3,OBJENTS          Point to first entry
OBLOCULP C     R3,LSTOBJAD         Reached last entry?
         BNL   THISOBJ             Yes, show it
         CLC   OEUSER,SELOBJNM     Up to user/job name?
         BE    THISOBJ             Yes
         BH    PREVOBJ             Yes, past it so back up one
         AH    R3,OELEN            No, point to next entry
         B     OBLOCULP
PREVOBJ  LA    R2,OBJENTS          Get first entry address
         CR    R2,R3               At first entry?
         BE    THISOBJ             Yes, can't go back one
         LR    R2,R3               No, point to this entry
         BCTR  R2,0                Point to last halfword
         BCTR  R2,0                         of previous entry
         SH    R3,0(,R2)           Point to previous entry
THISOBJ  XC    SELOBJNM,SELOBJNM   Clear member name to be located
         XC    SELOBJNM+2(256),SELOBJNM+2
         NI    STATUS4,255-$4REFR  Reset refresh flag
         TM    OBJFLAGS,OEREV      Just processed a member?
         BNO   OBJHEAD             No
         NI    OBJFLAGS,255-OEREV  Yes, reset flag
         CLC   ISPFPAGE,OBJCTCNT   Can all members be shown at once?
         BNH   OBJHEAD             No, so do not adjust behaviour
         ST    R3,CUROBJAD         Yes, remember member of interest
         LA    R3,OBJENTS          Point to first entry
OBJHEAD  ST    R3,TOPOBJAD         Save top member entry address
         MVI   HDCOLOR,X'05'       Clear screen to turquoise blanks
         L     R15,=A(REVHEAD)     Point to heading routine
         BASR  R14,R15             Initialise first two screen lines
         L     R2,SCREENBF         Point to the primary buffer
         A     R2,SCRNCOLS         Point to the second primary line
         LR    R14,R2
         LA    R0,12
         SLR   R14,R0              Back up twelve bytes
         LA    R1,1                Count **END**
         A     R1,OBJCTCNT         Get list entry count in binary
         CVD   R1,DOUBLE           Get list entry count in decimal
         LA    R1,11(,R14)         Point to last digit
         MVC   4(8,R14),ED7DASHO   Load edit mask
         EDMK  4(8,R14),DOUBLE+4   Show up to 9999999 entries correctly
         LR    R14,R1
         SLR   R14,R0              Back up twelve bytes before number
         L     R1,OESEQNO          Get current row number in binary
         CVD   R1,DOUBLE           Get current row number in decimal
         LA    R1,7(,R14)          Point to last digit
         MVC   8(4,R14),=C' of '
         MVC   0(8,R14),ED7DASHO   Load edit mask
         EDMK  0(8,R14),DOUBLE+4   Show up to row 9999999 correctly
         SLR   R1,R0               Back up twelve bytes before number
         MVC   7(5,R1),=C' Row '
         A     R2,SCRNCOLS         Point to the third primary line
         LR    R1,R2               Point to the third primary line
         A     R1,SCREENSZ         Point to the third shadow line
         MVI   0(R2),FLDOUTHI      Column headings in high intensity
         MVI   0(R1),X'36'         and yellow - underscored if sortable
         MVC   1(254,R1),0(R1)
         MVI   0(R1),X'06'         Column headings in underscore yellow
         MVC   1(2,R1),0(R1)
         MVI   11(R1),X'06'
         MVC   3(L'OBSUBHD1,R2),OBSUBHD1
         A     R2,SCRNCOLS         Point to the fourth screen line
         LR    R14,R2              Label the other columns
         LA    R0,L'OBSUBHD2+5
         SLR   R14,R0
         MVC   5(L'OBSUBHD2,R14),OBSUBHD2
         A     R14,SCREENSZ        Point to shadow of subheading
         MVI   0(R14),X'06'        Break up underscores into fields
         MVI   9(R14),X'06'
         MVI   12(R14),X'06'
         MVI   16(R14),X'06'
         MVI   22(R14),X'06'
         MVI   24(R14),X'06'
         MVI   33(R14),X'06'
         MVI   48(R14),X'06'
         L     R1,SCRNLNES         Get number of lines on screen
         SH    R1,=H'3'            Less three lines for headings
         XC    SELOBJNM,SELOBJNM   Clear member name in readiness
         XC    SELOBJNM+2(256),SELOBJNM+2
         SR    R0,R0               Clear for insert characters
         L     R7,=A(OBJFRMAT)     Point to line formatting routine
LODOBJNM CLC   0(4,R3),LASTOBJ     End of member list?
         BNER  R7                  No, format a PDSE directory entry
         DROP  R3                  @POBJENT
         MVI   0(R2),FLDOUTHI      High intensity
         LR    R0,R2               Point to primary buffer line
         S     R0,SCREENBF         Get offset into screen
         L     R1,SCREENSZ         Get size of screen
         SR    R1,R0               Get size of the rest of screen
         A     R0,SHADOWBF         Point to shadow buffer line
         LA    R15,X'06'           Get internal code for yellow
         SLL   R15,24              Set as pad and zero source length
         MVCL  R0,R14              Set rest of screen to yellow
         MVC   3(7,R2),EOOBJTXT    Indicate end of directory entries
         LM    R14,R15,OBJTOTSZ    Get program size total
         LA    R0,1023
         ALR   R15,R0              Round up to next kilobyte
         BC    12,*+8              No carry
         LA    R14,1(,R14)         Overflow
         SRDL  R14,10              Divide by 1024
         CVD   R15,DOUBLE
         MVC   11(10,R2),ED9O
         ED    11(10,R2),DOUBLE+3
         MVI   21(R2),C'K'
         CLC   OBJTOTSZ,OBJR24SZ   All programs have RMODE=24?
         BE    OBJR24OK            Yes, don't show same number twice
         LM    R14,R15,OBJR24SZ    Get RMODE=24 program size total
         LA    R0,1023
         ALR   R15,R0              Round up to next kilobyte
         BC    12,*+8              No carry
         LA    R14,1(,R14)         Overflow
         SRDL  R14,10              Divide by 1024
         CVD   R15,DOUBLE
         MVC   22(10,R2),ED9O
         ED    22(10,R2),DOUBLE+3
         MVC   32(6,R2),=CL6'K:R=24'
OBJR24OK LR    R6,R2               Copy current line pointer
         A     R6,SCRNCOLS         Point past current line
         LA    R0,L'OBSUBHD2+4
         SLR   R6,R0               Point to display area
         TM    DS1DSIND,DS1IND02   Is the data set modified bit on?
         BZ    OBJMODOK            No, display is correct
         MVC   18(8,R6),OBMODTXT   Yes, indicate this
OBJMODOK SR    R4,R4               Display creation date from ds1credt
         IC    R4,DS1CREDT         Get the creation year in binary
         LA    R4,1900(,R4)        Add origin for 1900-2155 support
         CVD   R4,DOUBLE           Last 2 year digits overwritten later
         UNPK  30(4,R6),DOUBLE+5(3)    Display 4-digit creation year
         L     R0,DOUBLE+4         Get the decimal year
         SRL   R0,4                Shift out sign
         SLL   R0,16               Put into top halfword
         ICM   R4,3,DS1CREDT+1     Get binary creation Julian day
         CVD   R4,DOUBLE
         L     R4,DOUBLE+4         Get decimal creation Julian day
         OR    R4,R0               Get yyyyddd+
         L     R15,OIDRDTAD
         BASR  R14,R15             Convert to yy-mm-dd
         MVC   32(8,R6),DOUBLE     Display creation yyyy-mm-dd
         MVC   41(6,R6),$VOLSER    Show data set volume serial number
DSPLYOBJ BAS   R14,POSHODSN        Put directory name into heading
         MVC   COMPON,@PDSELBL     Flag component for help
         MVC   REVHELP,REVHO00     Flag help panel to ISPF
         L     R15,=A(REVCOMM)     No parameter list passed
         BASR  R14,R15             Display screen and receive input
         MVC   KOUNT,TOPOBJAD      Save pre-scroll top member address

*  The 3270 data stream no longer has to be interpreted here because
*  REVCOMM will supply an 'S' selection code implied by the cursor
*  location if appropriate, and will also strip off any non-primary
*  input fields.  Further, primary input has had any PFK command
*  prefixing and command string parsing performed by REVCOMM.
*  Implicit and explicit selection codes are stored directly in REVBUF.
         TM    OPD0+6,PRESENT      Any subcommand requested?
         BNO   OBSELCHK            No, go check for selection codes
         L     R1,OPD0             Yes, point to it
         CLI   0(R1),C'L'          Possible locate request?
         BE    OBJCASOK            Yes, do not fiddle with operand case
         CLI   0(R1),C'B'          Possible browse request?
         BE    OBJCASOK            Yes, do not fiddle with operand case
         CLI   0(R1),C'S'          Possible select request?
         BNE   OBJKAPS             No, upper case it
         CLI   1(R1),C'O'          Possible sort request?
         BNE   OBJCASOK            No, must be select so leave case
OBJKAPS  L     R5,=A(KAPS)         Point to translate table
         TR    CMDAREA,0(R5)       Upper case all primary input
OBJCASOK L     R15,=A(OBJCMDTB)    Point to subcommand table
         LH    R5,OPD0+4           Get subcommand length code plus 1
         LA    R0,7
         CLR   R5,R0               Larger than maximum?
         BNH   OBJCMDLP            No
         LR    R5,R0               Yes, reduce to maximum
OBJCMDLP EX    R5,OBCMDTST         Found the subcommand?
         BL    OBJCMDBD            No, invalid subcommand
         BE    8(,R15)             Yes, perform it
         LA    R15,12(,R15)        Not yet, point to next entry
         B     OBJCMDLP            Continue subcommand table scan
OBCMDTST CLC   0(0,R1),0(R15)      <<< Executed >>>
OBJCMDBD MVI   MSG,20              Invalid command
         B     DSPLYOBJ            Go show the message

OBJLOC   BAS   R14,GTMEMNAM        Extract the specified member name
         B     FINDOBJ             Go locate entry

OBJTOP   LA    R3,OBJENTS          Point to first entry
         ST    R3,TOPOBJAD         Save new top entry pointer
         B     OBSELCHK            Check for selection codes

OBJBOTOM L     R3,LSTOBJAD         Point to **END**
         AH    R3,0(,R3)           Point past it
         BCTR  R3,0
         BCTR  R3,0                Point to **END**'s length indicator
         L     R1,ISPFPAGE         Get number of screen data lines
         B     OBJCLIMB                and scroll up one page

OBJUPCMD L     R15,=A(DIRSCROL)    Point to routine entry point
         BASR  R14,R15             Determine scroll amount
         LTR   R15,R15             Test return code
         BM    OBJBADOP            Invalid operand
         BP    OBJTOP              Scroll amount is maximum
         L     R3,TOPOBJAD         Point to current top entry
         BCTR  R3,0                Point to length of previous entry
         BCTR  R3,0
         LTR   R1,R1               Anything to scroll?
         BNP   FNDUPOBJ            No
OBJCLIMB LA    R2,OBJENTS          Point to first entry
UPONEOBJ CR    R3,R2               Pointing to before first entry?
         BL    FNDUPOBJ            Yes, use first entry
         SH    R3,0(,R3)           No, back up one entry
         BCT   R1,UPONEOBJ
FNDUPOBJ LA    R3,2(,R3)           Point to start of entry
         ST    R3,TOPOBJAD         Save new top entry pointer
         B     OBSELCHK            Check for selection codes

OBJDNCMD L     R15,=A(DIRSCROL)    Point to routine entry point
         BASR  R14,R15             Determine scroll amount
         LTR   R15,R15             Test return code
         BM    OBJBADOP            Invalid operand
         BP    OBJBOTOM            Scroll amount is maximum
         L     R3,TOPOBJAD         Point to current top entry
         LTR   R1,R1               Anything to scroll?
         BNP   OBJDNDON            No
DOWN1OBJ C     R3,LSTOBJAD         Pointing to last entry?
         BNL   OBJDNDON            Yes, use last entry
         AH    R3,0(,R3)           No, point to next entry
         BCT   R1,DOWN1OBJ
OBJDNDON ST    R3,TOPOBJAD         Save new top entry pointer
         B     OBSELCHK            Check for selection codes

OBJCAN   NI    STATUS,255-STPROF   Turn off profile rewrite flag
OBJEXIT  LM    R0,R1,OBFMREGS      Load FREEMAIN values
         L     R13,4(,R13)         Point to caller's save area
         FREEMAIN R,LV=(0),A=(1)   Free @PO#DYN
         LM    R14,R12,12(R13)     Restore registers
         SR    R15,R15
         STH   R15,RC              Overwrite previous non-zero RC
         BR    R14                 Return

OBJMISOP MVI   MSG,35              Missing operand
         B     DSPLYOBJ            Go display this message

OBJSORT  TM    OPD1+6,PRESENT      Any operand specified?
         BNO   OBJMISOP            No, so sort request type unknown
         L     R1,OPD1             Yes, point to it
         CLC   =C'SS',0(R1)        SSI?
         BE    OSRTSSI             Yes
         CLC   =C'AC',0(R1)        AC?
         BE    OSRTAUTH            Yes
         CLC   =C'AL',0(R1)        Alias name?
         BE    OSRTNAME            Yes
         CLC   =C'AT',0(R1)        Attributes?
         BE    OSRTATTR            Yes
         CLC   =C'AM',0(R1)        Addressing Mode?
         BE    OSRTMODE            Yes
         CLI   0(R1),C'M'          Mode?
         BE    OSRTMODE            Yes
         CLI   0(R1),C'C'          Changed?
         BE    OSRTDATE            Yes
         CLI   0(R1),C'D'          Date?
         BE    OSRTDATE            Yes
         CLI   0(R1),C'I'          Id?
         BE    OSRTUSER            Yes
         CLI   0(R1),C'N'          Name?
         BE    OSRTNAME            Yes
         CLI   0(R1),C'S'          Size?
         BE    OSRTSIZE            Yes
         CLI   0(R1),C'T'          TTR?
         BE    OSRTTTR             Yes
         CLI   0(R1),C'U'          Userid?
         BE    OSRTUSER            Yes
         CLI   0(R1),C'J'          Job name?
         BE    OSRTUSER            Yes
         CLI   0(R1),C'R'          Real name?
         BE    OSRTREAL            Yes
         CLI   0(R1),C'V'          Version?
         BE    OSRTVRSN            Yes
         CLI   0(R1),C'E'          Entry point?
         BE    OSRTEPA             Yes
OBJBADOP MVI   MSG,34              Invalid operand
         B     DSPLYOBJ            Go display this message

OSRTNAME MVC   DOUBLE(4),LSTOBJAD  Load first bubble pass limit
         LA    R2,OBJENTS          Point to first entry
         C     R2,DOUBLE           Any entries in this directory?
         BE    NOOBJCTS            No
         ST    R2,DOUBLE+4         Save address of first entry to sort
BUBLOBJN MVI   STATUS3,0           Reset sort swap flag
         MVC   OPEND,DOUBLE+4      Update start of bubble pass limit
         L     R2,OPEND            Point to first entry to sort
         MVC   DOUBLE+4(4),DOUBLE  Update end of bubble pass limit
NEXTOBJN LR    R1,R2
         AH    R2,0(,R1)           Point to second entry for compare
         C     R2,DOUBLE+4         Reached end of pass?
         BE    FINLOBJN            Yes, check for final pass
         LA    R4,OENAME-@POBJENT(,R1)
         LA    R6,OENAME-@POBJENT(,R2)
         LH    R5,OENMLN-@POBJENT(,R1)
         LH    R7,OENMLN-@POBJENT(,R2)
         ICM   R7,8,POBLANKS       Set pad character
         CLCL  R4,R6               Compare entry names
         BNH   NEXTOBJN            These two are in order
         BAS   R14,SWAPOBJS        Out of order so bubble down one
         B     NEXTOBJN            Process next entry
FINLOBJN TM    STATUS3,$3BUBL      Any entries bubbled in this pass?
         BNO   EXITOBJN            No, exit from sort by name
         MVI   STATUS3,0           Yes, reset sort swap flag
         L     R1,DOUBLE           Point past entries to sort
         BCTR  R1,0
         BCTR  R1,0                Point to trailing length field
         LA    R2,OPEND            Point to first entry to sort
         CR    R1,R2               Backed up too far?
         BL    EXITOBJN            Yes, must be all sorted now
         SH    R1,0(,R1)           Point to before last unsorted entry
BACKOBJN LR    R2,R1
         SH    R1,0(,R2)           Point to previous entry for compare
         LA    R4,OENAME-@POBJENT+2(,R1)
         LA    R6,OENAME-@POBJENT+2(,R2)
         LH    R5,OENMLN-@POBJENT+2(,R1)
         LH    R7,OENMLN-@POBJENT+2(,R2)
         ICM   R7,8,POBLANKS       Set pad character
         CLCL  R4,R6               Compare entry names
         BNH   BAKUPOBJ            These two are in order
         BAS   R14,SWPBKOBJ        Out of order so bubble up one
BAKUPOBJ C     R1,OPEND            Back to start of entries to sort?
         BNL   BACKOBJN            Process previous entry
         TM    STATUS3,$3BUBL      Any entries bubbled in this pass?
         BO    BUBLOBJN            Yes, do another pass
EXITOBJN MVI   MSG,62              Sorted by name
         B     FINDOBJ

OSRTDATE LA    R0,OEDATE-@POBJENT  Get sort field offset
         LA    R15,70              Sorted by date/time
         SLL   R15,8               Promote to correct byte
         LA    R15,$3DATE(,R15)    Get sort flag type
         SLL   R15,8               Clear execute length code byte
         LA    R15,L'OEDTTM-1(,R15) Get sort field length code
         ICM   R15,8,OBJHEX        Flag descending sort request
         B     SORTOBJ

OSRTSIZE LA    R0,OESIZE-@POBJENT  Get sort field offset
         LA    R15,63              Sorted by size
         SLL   R15,8               Promote to correct byte
         LA    R15,$3SIZE(,R15)    Get sort flag type
         SLL   R15,8               Clear execute length code byte
         LA    R15,L'OESIZE-1(,R15) Get sort field length code
         ICM   R15,8,OBJHEX        Flag descending sort request
         B     SORTOBJ

OSRTTTR  LA    R0,OETTR-@POBJENT   Get sort field offset
         LA    R15,73              Sorted by TTR (MLT)
         SLL   R15,8               Promote to correct byte
         LA    R15,$3TTR(,R15)     Get sort flag type
         SLL   R15,8               Clear execute length code byte
         LA    R15,L'OETTR(,R15)   Get sort field length code
         B     SORTOBJ

OSRTUSER LA    R0,OEUSER-@POBJENT  Get sort field offset
         LA    R15,72              Sorted by user/job
         SLL   R15,8               Promote to correct byte
         LA    R15,$3USER(,R15)    Get sort flag type
         SLL   R15,8               Clear execute length code byte
         LA    R15,L'OEUSER-1(,R15) Get sort field length code
         B     SORTOBJ

OSRTREAL LA    R0,OEREAL-@POBJENT  Get sort field offset
         LA    R15,150             Sorted by real name
         SLL   R15,8               Promote to correct byte
         LA    R15,$3PDSE(,R15)    Get sort flag type
         MVI   OBJFLAGS,OESREAL    Set PDSE sort type
         SLL   R15,8               Clear execute length code byte
         LA    R15,L'OEREAL-1(,R15) Get sort field length code
         B     SORTOBJ

OSRTAUTH LA    R0,OEAC-@POBJENT    Get sort field offset
         LA    R15,151             Sorted by authorization code
         SLL   R15,8               Promote to correct byte
         LA    R15,$3PDSE(,R15)    Get sort flag type
         MVI   OBJFLAGS,OESAUTH    Set PDSE sort type
         SLL   R15,8               Clear execute length code byte
         LA    R15,2-1(,R15)       Get sort field length code
         ICM   R15,8,OBJHEX        Flag descending sort request
         B     SORTOBJ

OSRTMODE LA    R0,OEATTR4-@POBJENT Get sort field offset
         LA    R15,152             Sorted by RMODE/AMODE
         SLL   R15,8               Promote to correct byte
         LA    R15,$3PDSE(,R15)    Get sort flag type
         MVI   OBJFLAGS,OESMODE    Set PDSE sort type
         SLL   R15,8               Clear execute length code byte
         LA    R15,L'OEATTR4-1(,R15) Get sort field length code
         B     SORTOBJ

OSRTATTR LA    R0,OEATTRS-@POBJENT Get sort field offset
         LA    R15,153             Sorted by attributes
         SLL   R15,8               Promote to correct byte
         LA    R15,$3PDSE(,R15)    Get sort flag type
         MVI   OBJFLAGS,OESATTR    Set PDSE sort type
         SLL   R15,8               Clear execute length code byte
         LA    R15,7-1(,R15)       Get sort field length code
         ICM   R15,8,OBJHEX        Flag descending sort request
         B     SORTOBJ

OSRTVRSN LA    R0,OEPMFMT-@POBJENT Get sort field offset
         LA    R15,154             Sorted by PM version
         SLL   R15,8               Promote to correct byte
         LA    R15,$3PDSE(,R15)    Get sort flag type
         MVI   OBJFLAGS,OESVRSN    Set PDSE sort type
         SLL   R15,8               Clear execute length code byte
         LA    R15,3-1(,R15)       Get sort field length code
         ICM   R15,8,OBJHEX        Flag descending sort request
         B     SORTOBJ

OSRTEPA  LA    R0,OEEPA-@POBJENT   Get sort field offset
         LA    R15,155             Sorted by entry point
         SLL   R15,8               Promote to correct byte
         LA    R15,$3PDSE(,R15)    Get sort flag type
         MVI   OBJFLAGS,OESEPA     Set PDSE sort type
         SLL   R15,8               Clear execute length code byte
         LA    R15,L'OEEPA-1(,R15) Get sort field length code
         ICM   R15,8,OBJHEX        Flag descending sort request
         B     SORTOBJ

OSRTSSI  LA    R0,OESSI-@POBJENT   Get sort field offset
         LA    R15,71              Sorted by SSI
         SLL   R15,8               Promote to correct byte
         LA    R15,$3SSI           Get sort flag type
         SLL   R15,8               Clear execute length code byte
         LA    R15,L'OESSI-1(,R15) Get sort field length code

SORTOBJ  MVC   DOUBLE(4),LSTOBJAD  Load first bubble pass limit
         LA    R2,OBJENTS          Point to first entry
         C     R2,DOUBLE           Any entries in this directory?
         BE    NOOBJCTS            No
         ST    R2,DOUBLE+4         Save address of first entry to sort
BUBLPOBJ STCM  R15,2,STATUS3       Reset sort swap flag
         MVC   OPEND,DOUBLE+4      Update start of bubble pass limit
         L     R2,OPEND            Point to first entry to sort
         MVC   DOUBLE+4(4),DOUBLE  Update end of bubble pass limit
NEXTPOBJ LR    R1,R2
         AH    R2,0(,R1)           Point to second entry for compare
         C     R2,DOUBLE+4         Reached end of pass?
         BE    FINALOBJ            Yes, check for final pass
         LR    R3,R1               Point to first entry
         LR    R4,R2               Point to second entry
         AR    R3,R0               Point to first sort field
         AR    R4,R0               Point to second sort field
         LTR   R15,R15             Sorting into descending order?
         BM    DESCPOBJ            Yes
         EX    R15,COMPOBJ         No, compare sort fields
         BNH   NEXTPOBJ            These two are in order
         BAS   R14,SWAPOBJS        Out of order so bubble down one
         B     NEXTPOBJ            Process next entry
DESCPOBJ EX    R15,COMPOBJ         Compare sort fields
         BNL   NEXTPOBJ            These two are in order
         BAS   R14,SWAPOBJS        Out of order so bubble down one
         B     NEXTPOBJ            Process next entry
COMPOBJ  CLC   0(0,R3),0(R4)       <<< Executed >>>
COMPOBJB CLC   2(0,R3),2(R4)       <<< Executed >>>
FINALOBJ TM    STATUS3,$3BUBL      Any entries bubbled in this pass?
         BNO   OBJSORTX            No, exit from program object sort
         STCM  R15,2,STATUS3       Yes, reset sort swap flag
         L     R1,DOUBLE           Point past entries to sort
         BCTR  R1,0
         BCTR  R1,0                Point to trailing length field
         LA    R2,OPEND            Point to first entry to sort
         CR    R1,R2               Backed up too far?
         BL    OBJSORTX            Yes, must be all sorted now
         SH    R1,0(,R1)           Point to before last unsorted entry
BACKOBJ  LR    R2,R1
         SH    R1,0(,R2)           Point to previous entry for compare
         LR    R3,R1               Point to first entry
         LR    R4,R2               Point to second entry
         AR    R3,R0               Point to first sort field
         AR    R4,R0               Point to second sort field
         LTR   R15,R15             Sorting into descending order?
         BM    BDESCOBJ            Yes
         EX    R15,COMPOBJB        No, compare sort fields
         BNH   BKUPPOBJ            These two are in order
         BAS   R14,SWPBKOBJ        Out of order so bubble up one
         B     BKUPPOBJ            Done ascending sort test
BDESCOBJ EX    R15,COMPOBJB        Compare sort fields
         BNL   BKUPPOBJ            These two are in order
         BAS   R14,SWPBKOBJ        Out of order so bubble up one
BKUPPOBJ C     R1,OPEND            Back to start of entries to sort?
         BNL   BACKOBJ             Process previous entry
         TM    STATUS3,$3BUBL      Any entries bubbled in this pass?
         BO    BUBLPOBJ            Yes, do another pass
OBJSORTX STCM  R15,4,MSG           Show sorted message
         B     FINDOBJ

NOOBJCTS MVI   MSG,56              No members to process
         B     SAMEOBJS            Go show the message

SWAPOBJS TM    STATUS4,$4ATTN      Attention interrupt?
         BO    OSRTATTN            Yes, terminate sort
         LH    R7,0(,R1)           Get the length of the first entry
         LA    R6,OBJWRKBF         Point to the save area
         LR    R5,R7               Copy length
         LR    R4,R1               Point to first entry
         MVCL  R6,R4               Save first entry
         LR    R4,R2               Point to the second entry
         LH    R5,0(,R2)           Get the length of the second entry
         LR    R6,R1               Point to the first entry
         LR    R7,R5               Copy length
         MVCL  R6,R4               Overlay first entry with second
         LH    R7,OBJWRKBF         Get length of saved entry
         LA    R4,OBJWRKBF         Point to saved entry
         LR    R5,R7               Copy length
         MVCL  R6,R4               Copy back saved entry
         LR    R2,R1
         AH    R2,0(,R1)           Point to new location of first
         L     R6,4(,R1)           Swap sequence numbers
         MVC   4(4,R1),4(R2)
         ST    R6,4(,R2)
         OI    STATUS3,$3BUBL      Indicate movement in this pass
         ST    R2,DOUBLE           Update end of bubble pass limit
         BR    R14                 Return to bubble sort mainline
SWPBKOBJ TM    STATUS4,$4ATTN      Attention interrupt?
         BO    OSRTATTN            Yes, terminate sort
         LH    R7,2(,R1)           Get the length of the first entry
         LA    R6,OBJWRKBF         Point to the save area
         LR    R5,R7               Copy length
         LA    R4,2(,R1)           Point to first entry
         MVCL  R6,R4               Save first entry
         LA    R4,2(,R2)           Point to the second entry
         LH    R5,2(,R2)           Get the length of the second entry
         LA    R6,2(,R1)           Point to the first entry
         LR    R7,R5               Copy length
         MVCL  R6,R4               Overlay first entry with second
         LH    R7,OBJWRKBF         Get length of saved entry
         LA    R4,OBJWRKBF         Point to saved entry
         LR    R5,R7               Copy length
         MVCL  R6,R4               Copy back saved entry
         LR    R2,R1
         AH    R2,2(,R1)           Point to new location of first
         L     R6,6(,R1)           Swap sequence numbers
         MVC   6(4,R1),6(R2)
         ST    R6,6(,R2)
         OI    STATUS3,$3BUBL      Indicate movement in this pass
         LA    R2,2(,R2)           Point to actual start of 2nd entry
         ST    R2,DOUBLE+4         Update start of bubble pass limit
         BR    R14                 Return to bubble sort mainline
OSRTATTN MVI   MSG,59              Interrupt - directory sort ended
         B     OBJTOP              Attention hit so stop sorting

POSHODSN L     R2,SCREENBF         Point to primary/text screen buffer
         MVI   1(R2),C'-'          Re-initialize heading message text
         MVC   2(52,R2),1(R2)      Set message area to dashes
         LH    R15,$DSNAME         Get data set name length
         EX    R15,GTPDSENM        Load data set name into heading
         TR    1(44,R2),PERIODS    Handle bad code points in name
         LR    R1,R2               Point to primary/text screen buffer
         AR    R2,R15              Point past name
         MVI   1(R2),C' '          Supply blank after data set name
         MVC   MSGDSN,1(R1)        Save text for REVCOMM
         MVC   $MEMBER,POBLANKS    Clean up for session swap list
         BR    R14                 Return to caller
GTPDSENM MVC   1(0,R2),$DSNAME+2   <<< Executed >>>

GTMEMNAM TM    OPD1+6,PRESENT      Any operand specified?
         BNO   OBJMISOP            No, required member hint missing
         L     R6,OPD1             Yes, point to it
         LH    R7,OPD1+4           Get its length
         STH   R7,SELOBJNM         Save the length
         ICM   R7,8,POBLANKS       Pad target with blanks
         LA    R0,SELOBJNM+2       Point to the target
         LA    R1,256              Get the target length
         MVCL  R0,R6               Extract the specified member name
         TM    OBJFLAGS,OELWRCS    Any lower case present?
         BOR   R14                 Yes, better retain mixed case
         L     R1,=A(KAPS)         No, upper case the operand
         TR    SELOBJNM+2(256),0(R1)
         BR    R14                 Return to caller

OBSELCHK TM    STATUS4,$4REFR      Screen contents overwritten?
         BO    SAMEOBJS            Yes, no selection codes
         L     R0,SCRNCOLS         Get screen width
         LR    R1,R0               Copy it
         AR    R1,R0               Double it
         AR    R1,R0               Triple it
         A     R1,SCREENBF         Point to first displayed member
         LA    R1,1(,R1)           Point to actual selection code byte
         L     R4,KOUNT            Point to pre-scroll top entry
         B     OBSEL1ST
         USING @POBJENT,R4
OBJSELLP A     R1,SCRNCOLS         Point to next line
         C     R1,SHADOWBF         Gone past primary screen buffer?
         BNL   OBDYNCSR            Yes, check for cursor sort selection
         AH    R4,OELEN            Point to next internal entry
OBSEL1ST C     R4,LSTOBJAD         Reached end of directory?
         BNL   OBDYNCSR            Yes, check for cursor sort selection
         OI    0(R1),C' '          Fold selection code to upper case
         CLI   0(R1),C' '          Blank code?
         BE    OBJSELLP            Yes
         CLI   0(R1),C'.'          No-op code?
         BE    OBJSELLP            Yes
         CLI   0(R1),C'T'          Entry tag selection?
         BE    TAGPGMOB            Yes, go flag entry for later
         CLI   0(R1),C'R'          Entry tag selection reset?
         BE    RESPGMOB            Yes, go unflag entry
         CLI   0(R1),C'B'          SPF browse selection?
         BE    OISPFCHK            Yes, check validity
         CLI   0(R1),C'H'          History selection?
         BE    OBJHSTRY            Yes
         CLI   0(R1),C'M'          Module map selection?
         BE    OBJMAPIT            Yes
         CLI   0(R1),C'S'          Explicit REVIEW selection?
         BE    DOOBJREV            Yes, proceed
         CLI   0(R1),C'/'          Explicit REVIEW selection?
         BE    SLASHOBJ            Yes, proceed
         MVI   MSG,24              No, invalid selection code
         S     R1,SCREENBF         Get offset of problem line
         LA    R1,1(,R1)           Get position of problem code
         S     R1,SCRNCOLS
         S     R1,SCRNCOLS
         ST    R1,REVPOS           Specify cursor position
         MVC   REVCSR,=CL8'REVBUF' Specify cursor field
         B     SAMEOBJS            Go show the message

OBDYNCSR CLI   DYN_CSR,0           Cursor beyond column headings?
         BNE   SAMEOBJS            Definitely, do not trigger a sort
         CLI   DYN_CSR+1,4         Up to first sortable field?
         BL    SAMEOBJS            No, do not trigger a sort
         CLI   DYN_CSR+1,12        On first sortable field?
         BL    OSRTREAL            Yes, go trigger a sort
         BE    SAMEOBJS            Skip sort if before second field
         LH    R15,DYN_CSR         Get cursor location
         LA    R15,L'OBSUBHD2+4(,R15)
         S     R15,SCRNCOLS
         BM    OSRTNAME            Cursor was in second field
         LA    R1,OBJSRTAB         Point to cursor select sort table
OBJSRTLP CH    R15,0(,R1)          Cursor before trigger area?
         BL    SAMEOBJS            Yes, do not trigger a sort
         CH    R15,2(,R1)          Cursor after trigger area?
         BNH   OBJDOSRT            No, go trigger a sort
         LA    R1,8(,R1)           Yes, point to next entry
         B     OBJSRTLP            Continue table scan
OBJDOSRT L     R15,4(,R1)          Load routine address
         BR    R15                 Go branch to it

OBJSEL   BAS   R14,GTMEMNAM        Extract the specified member name
         L     R4,TOPOBJAD         Point to a valid entry for later
         CLC   =H'8',SELOBJNM      Long member name?
         BNL   DOOBJSEL            No, proceed with select
         B     OBJBADOP            Yes, invalid operand

SLASHOBJ MVI   DATAKV+1,1          Specify 'DATA' operand
DOOBJREV LH    R1,OENMLN           Get length of entry name
         LA    R0,OENAME           Point to entry name
         STH   R1,SELOBJNM         Save the length
         LA    R14,SELOBJNM+2      Point to target
         LA    R15,256             Get target length
         ICM   R1,8,POBLANKS       Set pad character
         MVCL  R14,R0              Load entry name to process
DOOBJSEL MVC   $MEMBER,SELOBJNM+2  Set member name for REVIEW2
         CLC   =H'8',SELOBJNM      Did whole member name fit?
         BNL   *+10                Yes
         MVC   $MEMBER,OEREAL      No, use real name
         OI    STATUS8,$8_S        Bounce back here if BLDL fails
         XC    MSGDSN,MSGDSN       Reset R of TTR as "no match" flag
         L     R15,=A(REVIEW2)     Get address of phase 2
         BASR  R14,R15             Call REVIEW phase 2
         TM    STATUS,STPODIR      Still in member select mode?
         BZ    OBJEXIT             No, exit was requested
         MVI   DATAKV+1,0          Yes, clear 'DATA' operand
         ICM   R1,15,FMTAREA       Any format loaded?
         BZ    OBJHSTOK            No
         USING @FMTAREA,R1
         CLC   =C'*OBJ',FMTNAME
         BNE   OBJHSTOK
         NI    MODE,255-MD_FMT     Turn off binder data formatting
         DROP  R1                  @FMTAREA
OBJHSTOK CLC   $MEMBER,OEREAL      Still at same member?
         BE    SAMEOBJP            Yes, position cursor at it
         ST    R4,TOPOBJAD         No, save new top of display
         OI    OBJFLAGS,OEREV      Flag just processed a member
         MVI   SELOBJNM+2,C' '     No
         MVC   SELOBJNM+3(255),SELOBJNM+2
         MVC   SELOBJNM+2(8),$MEMBER   Member name to search for
         LA    R1,8
         STH   R1,SELOBJNM         Set member name length
         B     FINDOBJ


OBJMAPIT OI    STATUS9,$9_M        Signal function request code
         B     *+8                 Do not set other flag
OBJHSTRY OI    STATUS9,$9_H        Signal function request code
         TM    OEATTR2,PMAR_NREP   Reprocessable program?
         BZ    DOOBJREV            Yes
         NI    STATUS9,255-$9_H-$9_M   Reset whichever flag was set
         MVI   MSG,88              NE attribute - metadata not retained
         B     SAMEOBJS            Go show the message


OBSPFCMD BAS   R14,GTMEMNAM        Extract the specified member name
         CLC   =H'8',SELOBJNM      Long member name?
         BL    OBJBADOP            Yes, invalid for primary command
         L     R4,TOPOBJAD         Point to a valid entry for later
         B     DOOBJSPF
OISPFCHK LH    R3,OENMLN           Get length of entry name
         LA    R2,OENAME           Point to entry name
         STH   R3,SELOBJNM         Save the length
         LA    R14,SELOBJNM+2      Point to target
         LA    R15,256             Get target length
         ICM   R3,8,POBLANKS       Set pad character
         MVCL  R14,R2              Load member name to process
DOOBJSPF MVC   $MEMBER,SELOBJNM+2  Set member name for REVISPF
         CLC   =H'8',SELOBJNM      Did whole member name fit?
         BNL   *+10                Yes
         MVC   $MEMBER,OEREAL      No, use real name
         ST    R4,TOPOBJAD         Save new top of display
         L     R15,=A(REVISPF)     Edit is a valid selection
         BASR  R14,R15             Call REVISPF
         LTR   R15,R15             Was the browse ok?
         BZ    SAMEOBJS            Yes, reshow member list
         CLI   DOUBLE+3,16         Any members present?
         BE    OBJRFRSH            No, magically refresh member list
         CLI   DOUBLE+3,14         Was the member in not found?
         BNE   NOBPDF14            No
         MVI   MSG,36              Member not found
         MVC   BLDLNAME,$MEMBER    Save member name for REVMSGS
         B     SAMEOBJS            Reshow list from the member
NOBPDF14 CLI   DOUBLE+3,12         Was the member empty?
         BNE   SAMEOBJS            No
         MVI   MSG,53              Empty member
         B     SAMEOBJS            Reshow list from the member


TAGPGMOB TM    OEFLAGS,OETAG       Already tagged?
         BNZ   OBJSELLP            Yes, take no action
         OI    OEFLAGS,OETAG       No, tag it now
         LA    R0,1
         A     R0,TAGCOUNT         Increment tagged member counter
         ST    R0,TAGCOUNT
         B     OBJSELLP

RESPGMOB TM    OEFLAGS,OETAG       Is the entry tagged?
         BZ    OBJSELLP            No, take no action
         NI    OEFLAGS,255-OETAG   Reset tag flag
         ICM   R0,15,TAGCOUNT      Get current tagged entry count
         BZ    OBJSELLP            Already zero so skip decrement
         BCTR  R0,0                Decrement tagged entry counter
         ST    R0,TAGCOUNT
         B     OBJSELLP

         DROP  R4                  @POBJENT


************************************************************
*                                                          *
*         TOGGLE TAG FLAG FOR ALL ENTRIES                  *
*                                                          *
************************************************************

OTAGFLIP SR    R14,R14             Flip all tag bits
         ST    R14,TAGCOUNT        Reset tagged entry counter
         LA    R15,OBJENTS         Point to first entry
         USING @POBJENT,R15
OTAGLOOP C     R15,LSTOBJAD        Reached end of entry list?
         BNL   OBSELCHK            Yes, now look at entry selection(s)
         XI    OEFLAGS,OETAG       No, toggle tag flag
         TM    OEFLAGS,OETAG       Is the entry now tagged?
         BZ    OTAGCTOK            No, now untagged so do not count
         LA    R14,1(,R14)         Yes, increment counter
         ST    R14,TAGCOUNT        Update counter in case last tag
OTAGCTOK AH    R15,OELEN           Point to next entry
         B     OTAGLOOP            Process next entry
         DROP  R15                 @POBJENT


************************************************************
*                                                          *
*         DISPLAY FROM THE NEXT TAGGED ENTRY               *
*                                                          *
************************************************************

OFINDTAG ICM   R0,15,TAGCOUNT      Any tagged entries?
         BZ    OBJNOTAG            No, nothing to find
         L     R3,TOPOBJAD         Point to the current top entry
         C     R3,LSTOBJAD         Is it end-of-directory?
         BL    OFNDTAGL            No
         LA    R3,OBJENTS          Yes, point to the first entry
         B     OFNDTAG1            Handle if first entry tagged
         USING @POBJENT,R3
OFNDTAGL AH    R3,OELEN            Point to next entry
OFNDTAG1 C     R3,LSTOBJAD         Reached end of directory?
         BNL   THISOBJ             Yes, end current scan
         TM    OEFLAGS,OETAG       Is this entry tagged?
         BO    THISOBJ             Yes, tagged entry found
         B     OFNDTAGL            Continue scan
         DROP  R3                  @POBJENT
OBJNOTAG MVI   MSG,92              No members are tagged
         B     SAMEOBJS            Go show the message


************************************************************
*                                                          *
*         UNTAG ALL ENTRIES WITHOUT REFRESH FROM DASD      *
*                                                          *
************************************************************

OTAGREST SR    R0,R0               Reset all tag flags
         ST    R0,TAGCOUNT         No entries will be tagged
         LA    R3,OBJENTS          Point to the first entry
         USING @POBJENT,R3
OTAGRESL C     R3,LSTOBJAD         End of entry list?
         BNL   SAMEOBJS            Yes
         NI    OEFLAGS,255-OETAG   Reset entry tag flag
         AH    R3,OELEN            No, point to next entry
         B     OTAGRESL            Continue pass
         DROP  R3                  @POBJENT


************************************************************
*                                                          *
*         PREPARE FOR DIRECTORY REFRESH                    *
*                                                          *
************************************************************

         USING @POBJENT,R3
OBJRFRSH L     R3,TOPOBJAD         Point to the current top entry
         LH    R1,OENMLN           Get length of entry name
         LA    R0,OENAME           Point to entry name
         STH   R1,SELOBJNM         Save the length
         LA    R14,$MEMBER         Point to target
         LA    R15,8               Get target length
         ICM   R1,8,POBLANKS       Set pad character
         MVCL  R14,R0              Load entry name to process
         LM    R0,R1,OBFMREGS      Load FREEMAIN values
         L     R13,4(,R13)         Point to caller's save area
         FREEMAIN R,LV=(0),A=(1)   Free @PO#DYN
         B     OBREFRSH            Go get latest data from disk
         DROP  R3                  @POBJENT


************************************************************
*                                                          *
*         PROCESS SEARCH REQUEST                           *
*                                                          *
************************************************************

OBSEARCH LA    R15,OBJENTS         Point to first entry
         C     R15,LSTOBJAD        Any entries in this directory?
         BNL   NOOBJCTS            No, nothing to do
         LH    R1,OPD1+4           Yes, get operand length
         LTR   R0,R1               Null string?
         BNP   OBDOSRCH            Yes, as if no operand
         BCTR  R0,0                Get length code
         STH   R0,STRINGL          Save it
         L     R0,OPD1             Point to operand
         LA    R14,STRING          Point to target
         LA    R15,L'STRING        Get its length
         MVCL  R14,R0              Load search string
         ST    R15,FINDCOL1        Reset columns
         MVI   FINDCOL2,X'7F'
         MVI   FINDSW,0            Reset FIND options
         MVI   FINDSW2,FUOL
OBDOSRCH L     R15,=A(REVSRCH)     Point to search processor routine
         CALL  (15),               Call search procesor                +
               (OBJENTS,           Address of first entry              +
               LSTOBJAD,           Address of last entry pointer       +
               OEFLAGS-@POBJENT,   Offset of tag flag                  +
               OELEN-@POBJENT,     Offset of length indicator          +
               OEREAL-@POBJENT),   Offset of member name               +
               MF=(E,MYPPL)
         MVI   MSG,85              Search interrupted
         TM    STATUS4,$4ATTN      Attention interrupt?
         BO    SAMEOBJS            Yes, notify user
         MVI   MSG,86              Search cancelled
         CLI   REPLY,X'7D'         Enter AID present?
         BNE   SAMEOBJS            No, search has been cancelled
         L     R0,TAGCOUNT         Get matched member count
         CVD   R0,DOUBLE
         MVI   MSG,87              Search complete
         L     R15,=A(REVMSGS)
         BASR  R14,R15             Fetch message text
         MVC   MSG+2+17(10),ED9O
         ED    MSG+2+17(10),DOUBLE+3
         LH    R0,MSG              Get the length of msg87
OSCHDMLP CLI   MSG+2+18,C' '       Leading blank?
         BNE   SAMEOBJS            No, message formatted
         MVC   MSG+2+18(25),MSG+2+19
         BCTR  R0,0
         STH   R0,MSG              Decrement message length
         B     OSCHDMLP            Repeat leading blank check


**********************************************************************
*                                                          *         *
*         DISPLAY DATA SET ATTRIBUTES                      *  GP@PG  *
*                                                          * APR2008 *
**********************************************************************

PDSEINFO LA    R1,$VOLSER          Point to @INFPARM structure
         L     R15,=A(REVDSCB)     Get routine entry point
         BASR  R14,R15             Iinvoke it
         B     SAMEOBJS            Refresh display
         TITLE '  R E V P D S E   -   S T A T I C   A R E A  '
ISITMGDT ISITMGD DCB=0,DATATYPE=YES,MF=L
LASTOBJ  DC    H'10',H'0',2H'0',H'10'
REVHO00  DC    CL8'REVHO00 '       Name of first REVPDSE help panel
OBJHEX   DC    C'0123456789ABCDEF' Hexadecimal digit translate table
         DC    C'GHIJKLMNOPQRSTUV' Extra digits for PM version
POBLANKS DC    CL8' '
OBMODTXT DC    CL8'MODIFIED'
EOOBJTXT DC    CL7'**END**'
OBJED11  DC    X'402020202020202020202120'
OBJ2GIG  DC    P'2147483648'       Unsigned value of top binary bit
OIDRDTAD DC    A(IDRDATE)          Date conversion routine address
RDOBJADR DC    A(READOBJ)

         LTORG


OBJGMLIM DC    F'8192',F'786432'
OBJEXLST DC    X'94',AL3(OBJUDA)
         DS    0F
OBJUDA   DC    XL(UDAEND-UDALEN)'00'
         ORG   OBJUDA
         DC    Y(UDAEND-UDALEN)
         DC    AL1(0,0,UDANORFU)
         ORG
OBJDCBS  DCB   DDNAME=-OBJLIB-,DSORG=PO,MACRF=(R),EXLST=OBJEXLST
OBJDCBL  EQU   *-OBJDCBS

OBJSRTAB DC    0F'0'                   Cursor sort table
         DC    Y(01,08),A(OSRTSIZE)
         DC    Y(10,11),A(OSRTAUTH)
         DC    Y(13,15),A(OSRTMODE)
         DC    Y(17,21),A(OSRTATTR)
         DC    Y(23,23),A(OSRTVRSN)
         DC    Y(25,32),A(OSRTEPA)
         DC    Y(34,47),A(OSRTDATE)
         DC    Y(49,56),A(OSRTUSER)
         DC    A(-1)

ED7DASHO DC    XL8'6020202020202120'
ED9O     DC    XL10'40202020202020202120'
OBSUBHD1 DC    C'RealName Alias-Name'
OBSUBHD2 DC    C'Size AC AMd At RU V Non-0-EP Save-Timestamp User/Job'

         DS    0H
         TITLE '  R E V P D S E  '
************************************************************
*                                                          *
*         FORMAT DIRECTORY ENTRY SCREEN LINE               *
*                                                          *
************************************************************

*   Unlike the normal PDS directory display generated by REVPDS,
*   this display is expandable to occupy the whole screen width.
*   The expandable field is the member alias name field which is
*   shown after the 8-byte real name field.  These two name fields
*   are always start in the same column counted from the left edge
*   of the screen, while all of the other data item fields always
*   start in the same column counted from the right screen edge.

         USING OBJFRMAT,R7
         USING @POBJENT,R3
OBJFRMAT DS    0H                  Format directory entry
         LR    R4,R2               Point to primary buffer line
         A     R4,SCREENSZ         Point to shadow buffer line
         MVI   0(R2),FLDINHI       High intensity for selection field
         MVI   1(R2),C'.'          Supply auto-selection dot
         MVI   1(R4),X'01'         Blue for auto-selection dot
         MVI   2(R2),FLDOUTLO      Low intensity for member attributes
         C     R3,CUROBJAD         Processed this member?
         BNE   OBJCUROK            No
         LA    R14,2(,R2)          Yes, point past period
         S     R14,SCREENBF        Get position of period
         MVI   1(R2),C' '          Clear auto-selection dot
         SR    R0,R0               Get zero
         S     R14,SCRNCOLS
         S     R14,SCRNCOLS
         ST    R14,REVPOS          Specify cursor position
         MVC   REVCSR,=CL8'REVBUF' Specify cursor field
         ST    R0,CUROBJAD         Clear pending cursor placement
OBJCUROK MVI   3(R4),X'05'         Turquoise for member attributes
         TM    OEATTR4,PMAR_RMOD   RMODE=ANY?
         BNO   OBJATTRS            No
         ICM   R14,15,TAGCOUNT     Any members tagged?
         BNZ   *+8                 Yes, highlight tagged members only
         MVI   2(R2),FLDOUTHI      No, make it high intensity
         MVI   3(R4),X'04'         Show entry in green
OBJATTRS L     R6,SCRNCOLS         Get screen width
         LA    R0,4
         SR    R6,R0               Get target length
         EX    R6,OBJSPRED         Spread attributes along screen line
         TM    OEFLAGS,OETAG       Is this member tagged?
         BNO   OBJTAGOK            No, leave as low intensity
         MVI   2(R2),FLDOUTHI      Yes, make it high intensity
         OI    3(R4),X'20'         Show tagged name in reverse video
         LA    R6,7                Get member name length code
         TM    OEFLAG,SMDE_FLAG_ALIAS
         BNO   OBJTAGNM            Member is not an alias
         LH    R6,OENMLN           Get the alias name length
         LA    R0,148              Get maximum name length to show
         CR    R6,R0               Too big?
         BNH   *+6                 No
         LR    R6,R0               Yes, reduce to maximum
         LA    R6,8(,R6)           Also highlight real name
OBJTAGNM EX    R6,OBJSPRED         Show name(s) in reverse video
OBJTAGOK LA    R0,L'OBSUBHD2+4
         LR    R6,R2               Copy line pointer
         A     R6,SCRNCOLS         Point to next line
         SLR   R6,R0               Point back to current format area
         UNPK  0(9,R6),OESIZE(5)   Show program virtual storage size
         TR    0(8,R6),OBJHEX-C'0'
         MVI   8(R6),C' '
         LA    R15,0(,R6)          Point to size display
         LA    R0,7                Get maximum suppression count
OBJSIZLP CLI   0(R15),C'0'         Leading zero?
         BNE   OBJSIZOK            No
         MVI   0(R15),C' '         Yes, suppress it
         LA    R15,1(,R15)         Point to next digit
         BCT   R0,OBJSIZLP         Go check it
OBJSIZOK TM    OEATTR3,PMAR_XAPF   APF information present?
         BNO   OBJAPFOK            No
         UNPK  9(3,R6),OEAC(2)     Yes, show APF authorization code
         TR    9(2,R6),OBJHEX-C'0'
         MVI   11(R6),C' '
OBJAPFOK TM    OEATTR1,PMAR_OVLY   Segment overlay program?
         BNO   OBJOVROK            No
         MVC   12(2,R6),=C'OV'     Yes
         B     OBJAMDOK            Must be AMODE=24
OBJSPRED MVC   4(0,R4),3(R4)       <<< Executed >>>
OBJAMCHK TM    OEATTR4,X'00'       <<< Executed >>>
OBJOVROK LA    R15,X'0203'         Load masks
         TM    OEFLAG,SMDE_FLAG_ALIAS
         BNO   *+8                 Member is not an alias
         SLL   R15,2               Shift mask for alias
         EX    R15,OBJAMCHK        Is it AMODE=24?
         BZ    OBJAMDOK            Yes, leave field blank
         MVC   12(3,R6),=C'ANY'    No
         BO    OBJAMDOK            AMODE=ANY
         SRL   R15,8
         MVC   13(2,R6),=C'31'
         EX    R15,OBJAMCHK        Check first AMODE bit
         BO    OBJAMDOK            AMODE=31
         MVC   13(2,R6),=C'64'     AMODE=64
OBJAMDOK TM    OEATTR1,PMAR_EXEC   Executable program?
         BO    OBJEXCOK            Yes
         MVC   16(2,R6),=C'NX'     No
         B     OBJATROK
OBJEXCOK TM    OEATTR2,PMAR_NREP   Reprocessable program?
         BZ    OBJREPOK            Yes
         MVC   16(2,R6),=C'NE'     No
         B     OBJATROK
OBJREPOK TM    OEATTR1,PMAR_SCTR   Scatter format program?
         BZ    OBJSCTOK            No
         MVC   16(2,R6),=C'SC'     Yes
         B     OBJATROK
OBJSCTOK TM    OEATTR1,PMAR_LOAD   Only loadable program?
         BZ    OBJLODOK            No
         MVC   16(2,R6),=C'OL'     Yes
         B     OBJATROK
OBJLODOK TM    OEATTR3,PMAR_PAGA   Page aligned program?
         BZ    OBJPAGOK            No
         MVC   16(2,R6),=C'PG'     Yes
         B     OBJATROK
OBJPAGOK TM    OEATTR2,PMAR_TSTN   Compiled with TEST symbols?
         BZ    OBJTSTOK            No
         MVC   16(2,R6),=C'TS'     Yes
         B     OBJATROK
OBJTSTOK TM    OEATTR5,PMARL_NMIG  Non-migratable back to PDS?
         BZ    OBJATROK            No
         MVC   16(2,R6),=C'NM'     Yes
OBJATROK TM    OEATTR2,PMAR_REFR   Refreshable program?
         BZ    OBJREFOK            No
         MVC   19(2,R6),=C'RF'     Yes
         B     OBJREUOK
OBJREFOK TM    OEATTR1,PMAR_RENT   Reenterable program?
         BZ    OBJRENOK            No
         MVC   19(2,R6),=C'RN'     Yes
         B     OBJREUOK
OBJRENOK TM    OEATTR1,PMAR_REUS   Reusable program?
         BZ    OBJREUOK            No
         MVC   19(2,R6),=C'RU'     Yes
OBJREUOK MVC   22(1,R6),OEPMFMT    Copy program management version
         NI    22(R6),X'1F'        Ensure in range
         TR    22(1,R6),OBJHEX     Make displayable
         CLI   OEPMSUB,0           Any sublevel?
         BE    OBJSUBOK            No
         MVC   23(1,R6),OEPMSUB    Yes, copy it
         NI    23(R6),X'1F'        Ensure in range
         TR    23(1,R6),OBJHEX     Make displayable
         CLI   23(R6),C'0'         Decimal?
         BL    OBJSUBBG            No
         A     R6,SCREENSZ         Yes, point to its shadow
         OI    23(R6),X'40'        Make sublevel a superscript
         S     R6,SCREENSZ         Back to the primary buffer
         B     OBJSUBOK
OBJSUBBG XI    23(R6),X'40'        Make alphabetic digit lower case
OBJSUBOK ICM   R0,15,OEEPA         Zero entry point offset?
         BZ    OBJEPAOK            Yes
         UNPK  24(9,R6),OEEPA(5)   No, show entry point offset
         TR    24(8,R6),OBJHEX-C'0'
         MVI   32(R6),C' '
         LA    R15,24(,R6)         Point to size display
         LA    R0,7                Get maximum suppression count
OBJEPALP CLI   0(R15),C'0'         Leading zero?
         BNE   OBJEPAOK            No
         MVI   0(R15),C' '         Yes, suppress it
         LA    R15,1(,R15)         Point to next digit
         BCT   R0,OBJEPALP         Go check it
OBJEPAOK TM    OEATTR7,PMARL_DLLENA
         BNO   OBJDLLOK
         MVI   24(R6),C'd'         Program object is DLL-enabled
OBJDLLOK TM    OEDATE+3,X'0F'      Expected sign present?
         BNO   OBJPM2OK            No, PM2 details not available
         L     R4,OEDATE           Show the save date
         L     R15,FLCCVT          CVT
         CLM   R4,7,CVTDATE+1-CVT(R15)
         BNE   OBJDATOK            Not saved today
         A     R6,SCREENSZ         Point to shadow buffer
         OI    33(R6),X'07'        Show date in white
         MVC   34(7,R6),33(R6)
         S     R6,SCREENSZ         Point to back to text buffer
OBJDATOK L     R15,OIDRDTAD
         BASR  R14,R15
         MVC   33(8,R6),DOUBLE
         UNPK  DOUBLE,OETIME       Show the save time
         MVC   42(2,R6),DOUBLE+2
         MVI   44(R6),C':'
         MVC   45(2,R6),DOUBLE+4
         MVC   48(8,R6),OEUSER     Show user or job name
OBJPM2OK MVC   3(8,R2),OEREAL      Show the real name
         TM    OEATTR4,PMAR_ALTP   Alternate primary name?
         BZ    OBJALTOK            No
         MVI   11(R2),C'*'         Yes
OBJALTOK TM    OEFLAG,SMDE_FLAG_ALIAS
         BO    OBJALIAS            Member is an alias
         TM    OEATTR3,PMAR_XSSI   System status information present?
         BO    OBJDOSSI            Yes
         LA    R0,1023             Round up to next kilobyte
         AL    R0,OESIZE           Get load module size
         SRL   R0,10               Divide by 1024
         CVD   R0,DOUBLE
         MVC   12(10,R2),ED9O
         ED    12(10,R2),DOUBLE+3
         MVI   22(R2),C'K'
         B     OBJLNDON
OBJDOSSI MVC   12(4,R2),=C'SSI='   Show system status information
         UNPK  16(9,R2),OESSI(5)
         TR    16(8,R2),OBJHEX-C'0'
         MVI   24(R2),C' '
         B     OBJLNDON            Line for real member complete
OBJALIAS L     R0,SCRNCOLS         Get the screen width
         LA    R14,12              Must not run into shadow buffer
         SR    R0,R14              Get maximum name length to show
         LH    R14,OENMLN          Get the name length
         CR    R14,R0              Too big?
         BNH   *+6                 No
         LR    R14,R0              Yes, reduce to maximum
         BCTR  R14,0               Decrement for execute
         EX    R14,OBJLDENM        Load entry name
         LA    R14,1+12(R14,R2)    Point past loaded entry name
         MVI   0(R14),C' '         Separate name from stat data
         TM    OEATTR7,PMARL_HIDE  Can alias name be hidden?
         BNO   OBJHIDOK            No
         MVI   11(R2),C'('         Yes, show alias name in parentheses
         MVI   0(R14),C')'
OBJHIDOK CLI   2(R14),C' '         Possibly just one non-blank?
         BNE   OBJLNDON            No
         MVI   1(R14),C' '         Yes, erase useless non-blank
OBJLNDON L     R14,SCRNCOLS
         LA    R0,4
         SR    R14,R0              Get line's text length code
         EX    R14,OBJXLATE        Handle undisplayable characters
         A     R2,SCRNCOLS         Point to next detail screen line
         AH    R3,OELEN            Point to next entry
         BCT   R1,LODOBJNM
         B     DSPLYOBJ            Screen now filled
OBJLDENM MVC   12(0,R2),OENAME     <<< Executed >>>
OBJXLATE TR    3(0,R2),PERIODS     <<< Executed >>>

         DROP  R3,R7               @POBJENT, OBJFRMAT

         LTORG
         DS    0H
         EJECT
************************************************************
*                                                          *
*         READ AND STORE DIRECTORY ENTRY DATA              *
*                                                          *
************************************************************

         USING READOBJ,R7          AMODE=31 for DESERV buffers
READOBJ  DS    0H                  Process PDSE directory
         MVC   DESERVD,DESERVS     Initialize DESERV parameter list
         SR    R8,R8               Initialize entry counter
         ST    R8,TAGCOUNT         Initialize tagged entry count
         LA    R3,OBJENTS          Point to first entry
         ST    R3,TOPOBJAD         Show from top
         XC    OBJTOTSZ,OBJTOTSZ   Reset size totals
         XC    OBJR24SZ,OBJR24SZ

         DESERV FUNC=GET_ALL,      Get all PDSE directory entries      +
               AREAPTR=OBJAREA@,   Supply pointer for returned area    +
               CONN_INTENT=NONE,   Do not retain any connections       +
               DCB=OBJDCBD,        Supply open BPAM DCB                +
               RETCODE=OBJRETCD,   Supply return code area             +
               RSNCODE=OBJRSNCD,   Supply reason code area             +
               SUBPOOL=33,         Supply subpool id                   +
               MF=(E,DESERVD,COMPLETE)
         ICM   R15,15,OBJRETCD     Success?
         BZ    GETALLOK            Yes

         MVC   MSG+2(19),=CL19'DESERV FAILED - RC='
         UNPK  MSG+2+19(9),OBJRETCD(5)
         TR    MSG+2+19(8),OBJHEX-C'0'
         MVC   MSG+2+27(5),=CL5' RSN='
         UNPK  MSG+2+32(9),OBJRSNCD(5)
         TR    MSG+2+32(8),OBJHEX-C'0'
         MVI   MSG+2+40,C' '
         LA    R0,40
         STH   R0,MSG              Set message length
         OI    STATUS7,$7BELL      Request audible alarm
         B     OBJCLOSE

         USING @POBJENT,R3
GETALLOK EQU   *
         L     R4,OBJAREA@         Point to returned area
         USING DESB,R4
         L     R5,DESB_COUNT       Get the buffer SMDE count
         LA    R4,DESB_DATA        Point to first SMDE
         DROP  R4                  DESB
GASMDELP EQU   *
         USING SMDE,R4
         XC    @POBJENT(OENAME-@POBJENT),@POBJENT
         LA    R8,1(,R8)           Increment entry count
         ST    R8,OESEQNO          Set entry's internal sequence number
         MVC   OEFLAG,SMDE_FLAG    Copy alias and other flags
         MVC   OETTR,SMDE_MLT      Copy the "TTR"
         MVC   OEREAL,POBLANKS     Prepare for not an alias
         TM    OEFLAG,SMDE_FLAG_ALIAS
         BNO   POBJALOK            Not an alias
         MVC   OEREAL+1(6),=CL6'*ALIAS'
POBJALOK SR    R6,R6
         ICM   R6,3,SMDE_NAME_OFF  Get offset to name section
         ALR   R6,R4               Point to name section
         USING SMDE_NAME,R6
         SR    R15,R15
         ICM   R15,3,SMDE_NAME_LEN Get length of name
         LA    R14,SMDE_NAME_VAL   Point to entry name
         STH   R15,OENMLN          Save the name length
         LR    R1,R15              Copy length
         LA    R0,OENAME           Point to target name field
         MVCL  R0,R14              Load the entry name
         TM    OBJFLAGS,OELWRCS    Already found lower case?
         BO    POBJLCOK            Yes, skip some work
         LA    R14,SMDE_NAME_VAL   Point to entry name
         LH    R15,OENMLN          Reload the name length
         L     R2,=A(EDTLOWER)     Point to translate table
         BCTR  R15,0               Decrement for execute
         EX    R15,OBJLCTRT        Any lower case in name?
         BZ    POBJLCOK            No
         OI    OBJFLAGS,OELWRCS    Yes, flag it
POBJLCOK TM    OEFLAG,SMDE_FLAG_ALIAS
         BO    POBJRNOK            Is an alias
         LH    R15,OENMLN          Get length of name
         LA    R14,SMDE_NAME_VAL   Point to entry name
         ICM   R15,8,POBLANKS      Set pad character
         LA    R0,OEREAL           Point to target name field
         LA    R1,8                Get target length
         MVCL  R0,R14              Copy real member name
POBJRNOK SR    R6,R6
         ICM   R6,3,SMDE_PNAME_OFF Get offset to primary name section
         BZ    OBJPRMOK            Not an alias
         ALR   R6,R4               Point to name section
         ICM   R15,3,SMDE_NAME_LEN Get length of name
         LA    R14,SMDE_NAME_VAL   Point to entry name
         ICM   R15,8,POBLANKS      Set pad character
         LA    R0,OEREAL           Point to target name field
         LA    R1,8                Get length of target
         MVCL  R0,R14              Load the entry's primary name
         DROP  R6                  SMDE_NAME
OBJPRMOK SR    R6,R6
         ICM   R6,3,SMDE_PMAR_OFF  Get offset to PMAR section
         ALR   R6,R4               Point to PMAR section
         MVC   OESSI,OBJHIGH4      Sort missing SSI high
         USING PMAR,R6
         MVC   OEPMFMT,PMAR_LVL    Copy program object level
         MVC   OEBNDLVL,PMAR_PLVL  Copy binder level
         MVC   OEATTRS,PMAR_ATR    Copy 4 program attribute bytes
         MVC   OEAC,PMAR_AC        Copy APF authorization code
         TM    PMAR_ATR3,PMAR_XAPF APF information present?
         BNO   *+8                 No
         OI    OESPARE,X'80'       Yes, flag sort sorting
         MVC   OESIZE,PMAR_STOR    Copy program storage size
         MVC   OEEPA,PMAR_EPA      Copy entry point offset
         TM    OEATTR3,PMAR_XSSI   System status information present?
         BNO   OBJHVSSI            No, leave high values for sort
         MVC   OESSI,PMAR_SSI      Copy system status information
OBJHVSSI TM    OEATTR3,PMAR_LFMT   Does PMARL follow PMAR?
         BZ    PMARLDON            No
         LA    R6,PMAR_END         Point past PMAR
         DROP  R6                  PMAR
         USING PMARL,R6
         MVC   OEATTRL,PMARL_ATR   Copy 2 attribute flag bytes
         MVI   OEUSER,X'FF'        Sort missing user/job high
         CLI   OEPMFMT,PMAR_PM2_VAL
         BL    PMARLDON            PM2 fields not available
         MVC   OEPMSUB,PMARL_PO_SUBLVL
         MVC   OEDATE,PMARL_DATE   Copy save date
         MVC   OETIME,PMARL_TIME   Copy save time
         MVC   OEUSER,PMARL_USER   Copy user or job id
         CLI   OEPMFMT,PMAR_PM3_VAL
         BL    OBJPO3OK            PM3 fields not available
         MVC   OEATTR7,PMARL_PM3FL1
OBJPO3OK TM    OEFLAG,SMDE_FLAG_ALIAS
         BO    OCARY2OK            Do not count alias size
         CLC   PMARL_NSEG,=H'1'    More than one segment?
         BNH   PMARLDON            No
         SR    R0,R0               Reset accumulator
         TM    PMARL_ATR2,PMARL_1RMOD
         BO    OBJ1RMOD            First segment is RMODE=ANY
         ICM   R0,15,PMARL_1STOR   First segment is RMODE=24
OBJ1RMOD TM    PMARL_ATR2,PMARL_2RMOD
         BO    OBJ24SIZ            Second segment is RMODE=ANY
         ICM   R6,15,PMARL_2STOR   Second segment is RMODE=24
         AR    R0,R6               Accumulate size
         B     OBJ24SIZ            Have RMODE=24 size for program
         DROP  R6                  PMARL
PMARLDON TM    OEATTR4,PMAR_RMOD   RMODE=ANY?
         BO    OCARY1OK            Yes
         L     R0,OESIZE           Get program size
OBJ24SIZ AL    R0,OBJR24SZ+4       Add it to total
         ST    R0,OBJR24SZ+4
         BC    12,OCARY1OK         No carry
         LA    R0,1                Overflow
         AL    R0,OBJR24SZ
         ST    R0,OBJR24SZ
OCARY1OK TM    OEFLAG,SMDE_FLAG_ALIAS
         BO    OCARY2OK            Do not count alias size
         L     R0,OESIZE           Get program size
         AL    R0,OBJTOTSZ+4       Add it to total
         ST    R0,OBJTOTSZ+4
         BC    12,OCARY2OK         No carry
         LA    R0,1                Overflow
         AL    R0,OBJTOTSZ
         ST    R0,OBJTOTSZ
OCARY2OK LH    R6,OENMLN           Get entry name length
         LA    R6,OENAME-@POBJENT+2+3(,R6)
         SRL   R6,2                Fullword alignment
         SLL   R6,2                Get entry length
         STH   R6,OELEN            Save it
         LA    R1,0(R6,R3)         Point past this entry
         BCTR  R1,0
         BCTR  R1,0
         STH   R6,0(,R1)           Set trailing length indicator
         AH    R3,OELEN            Point to next internal entry
         C     R3,MAXOBJAD         Filled up internal storage?
         BH    POBJFULL            Yes, go handle it
         ICM   R0,15,SMDE_LEN      Get length of whole SMDE
         ALR   R4,R0               Point to next returned entry
         BCT   R5,GASMDELP         Process it
         DROP  R4                  SMDE
         L     R1,OBJAREA@         Point to returned area
         USING DESB,R1
         L     R0,DESB_LEN         Get the length SMDE
         MVC   OBJAREA@,DESB_NEXT  Save address of next buffer
         DROP  R1                  DESB
         ICM   R0,15,OBJAREA@      Any more buffers?
         BNZ   GETALLOK            Yes, process next buffer
         B     OBJCLOSE            No, terminate the read process

POBJFULL MVI   MSG,57              Region full - directory read ended

OBJCLOSE MVI   CLOSED,X'80'        Close BPAM DCB
         CLOSE (OBJDCBD),MF=(E,CLOSED)
         ST    R8,OBJCTCNT         Save count of entries in list
         MVC   0(10,R3),LASTOBJ    Denote end of entry list
         ST    R3,LSTOBJAD         Save address of last entry
         LA    R8,1(,R8)           Increment entry count
         ST    R8,OESEQNO          Set entry's internal sequence number
         FREEMAIN RU,SP=33         Free all the DESERV buffers
         LA    R3,10+7(,R3)        Point past last used doubleword
         SRL   R3,3
         SLL   R3,3                Ensure doubleword boundary
         LR    R2,R3               Address of unused dynamic area
         SR    R2,R13              Determine size of used dynamic area
         LR    R1,R3               Point to start of unused dyn area
         L     R0,OBFMREG0         Get total size of dynamic area
         SR    R0,R2               Get size of unused dynamic area
         BNP   OBJRDONE            If zero then bypass FREEMAIN
         FREEMAIN R,LV=(0),A=(1)   Free unused portion of dynamic area
         ST    R2,OBFMREG0         Save new size of dynarea
OBJRDONE XC    SELOBJNM,SELOBJNM   Reset member name to search for
         XC    SELOBJNM+2(256),SELOBJNM+2
         TM    STATUS,STNOMEM      Any useful member nominated?
         BO    OBJMEMOK            No, do not prime member to locate
         MVI   SELOBJNM+1,8        Yes, prime member to locate field
         MVI   SELOBJNM+2,C' '
         MVC   SELOBJNM+3(255),SELOBJNM+2
         MVC   SELOBJNM+2(8),$MEMBER
OBJMEMOK B     TOPOBJCT            Return to mainline

         DROP  R7,R3               READOBJ, @POBJENT

OBJLCTRT TRT   0(0,R14),0(R2)      <<< Executed >>>

DESERVS  DESERV FUNC=GET_ALL,MF=L
DESERVL  EQU   *-DESERVS

OBJHIGH4 DC    XL4'FFFFFFFF'
         LTORG
         DS    0H
         EJECT
************************************************************
*                                                          *
*         DIRECTORY DISPLAY SUBCOMMAND TABLE               *
*                                                          *
************************************************************

OBJCMDTB DS    0H                 Entries must be in collating sequence
         DC    CL8'+       '
         B     OBJDNCMD
         DC    CL8'-       '
         B     OBJUPCMD
         DC    CL8'=X      '
         B     OBJEXIT
         DC    CL8'B       '
         B     OBSPFCMD
         DC    CL8'BOT     '
         B     OBJBOTOM
         DC    CL8'BOTTOM  '
         B     OBJBOTOM
         DC    CL8'BROWSE  '
         B     OBSPFCMD
         DC    CL8'CAN     '
         B     OBJCAN
         DC    CL8'CANCEL  '
         B     OBJCAN
         DC    CL8'DOWN    '
         B     OBJDNCMD
         DC    CL8'END     '
         B     OBJEXIT
         DC    CL8'EXIT    '
         B     OBJEXIT
         DC    CL8'F       '
         B     OBSEARCH
         DC    CL8'FIND    '
         B     OBSEARCH
         DC    CL8'IFIND   '
         B     OFINDTAG
         DC    CL8'INFO    '
         B     PDSEINFO
         DC    CL8'L       '
         B     OBJLOC
         DC    CL8'LIST    '
         B     OBJLOC
         DC    CL8'LOC     '
         B     OBJLOC
         DC    CL8'LOCATE  '
         B     OBJLOC
         DC    CL8'REF     '
         B     OBJRFRSH
         DC    CL8'REFRESH '
         B     OBJRFRSH
         DC    CL8'RES     '
         B     OTAGREST
         DC    CL8'RESET   '
         B     OTAGREST
         DC    CL8'RETURN  '
         B     OBJEXIT
         DC    CL8'RFIND   '
         B     OFINDTAG
         DC    CL8'S       '
         B     OBJSEL
         DC    CL8'SEARCH  '
         B     OBSEARCH
         DC    CL8'SEL     '
         B     OBJSEL
         DC    CL8'SELECT  '
         B     OBJSEL
         DC    CL8'SORT    '
         B     OBJSORT
         DC    CL8'TAGFLIP '
         B     OTAGFLIP
         DC    CL8'TF      '
         B     OTAGFLIP
         DC    CL8'TOP     '
         B     OBJTOP
         DC    CL8'UP      '
         B     OBJUPCMD
         DC    H'-1'               End of table


         DROP  R11,R10,R13         REVPDSE, @PO#DYN

         DC    0D'0'               End of CSECT
         TITLE '  R E V P D S E   -   D Y N A M I C   A R E A  '
@PO#DYN  DSECT
         DS    18F                 Working save area
OBFMREGS EQU   *,8                 FREEMAIN register values
OBFMREG0 DS    F                   FREEMAIN register 0 value
OBFMREG1 DS    F                   FREEMAIN register 1 value
OBJTOTSZ DS    D                   Total size of all entries
OBJR24SZ DS    D                   Total size of all entries
TOPOBJAD DS    F                   Top entry address save area
LSTOBJAD DS    F                   Last entry address save area
CUROBJAD DS    F                   Current entry being processed
MAXOBJAD DS    F                   Top usable address of OBJENTS
OBJCTCNT DS    F                   Total number of entries in list
DESERVD  DS    XL(DESERVL)         DESERV parameter list
OBJRETCD DS    F                   Return code
OBJRSNCD DS    F                   Reason code
OBJAREA@ DS    F                   Return area pointer
OBJBUFAD DS    F                   Read buffer address
OBJBUFLN DS    F                   Read buffer length
OBJPLIST DS    7F                  Call parameter list
OBJDCBD  DS    XL(OBJDCBL)         PDSE BPAM DCB
OBJFLAGS DS    X                   Flag byte
OESREAL  EQU   X'80'               Sorted into real name order
OESAUTH  EQU   X'40'               Sorted into AC order
OESMODE  EQU   X'20'               Sorted into AMODE order
OESATTR  EQU   X'10'               Sorted into attributes order
OESVRSN  EQU   X'08'               Sorted into PM version order
OESEPA   EQU   X'04'               Sorted into EP offset order
OELWRCS  EQU   X'02'               Lower case used in name
OEREV    EQU   X'01'               Have just reviewed a member
SELOBJNM DS    H,CL256             User selected entry
OBJWRKBF DS    256D                2K work buffer
OBJENTS  DS    0D                  In-core entry list starts here

@POBJENT DSECT
OELEN    DS    H                   Length of entire internal entry
OEFLAGS  DS    XL2                 Internal flags
OETAG    EQU   X'40'               Entry is tagged (same as REVPDS)
OESEQNO  DS    XL4                 Internal entry sequence number
OEREAL   DS    CL8                 Real member name
OETTR    DS    XL3                 SMDE_MLT
OEFLAG   DS    X                   SMDE_FLAG
OESIZE   DS    XL4                 Program storage size
OEEPA    DS    XL4                 Entry point offset
OESSI    DS    XL4                 System status information
OEDTTM   EQU   *,8
OEDATE   DS    PL4                 Date saved
OETIME   DS    PL4                 Time saved
OEUSER   DS    CL8                 User or job identification
OEPMFMT  DS    X                   PMAR format level
OEPMSUB  DS    X                   Program Object sublevel
OEBNDLVL DS    X                   Binder level
OEATTRS  DS    0XL4
OEATTR1  DS    X                   Program attributes
OEATTR2  DS    X                   Program attributes
OEATTR3  DS    X                   Program attributes
OEATTR4  DS    X                   Program attributes
OEATTRL  DS    0XL2
OEATTR5  DS    X                   Program attributes
OEATTR6  DS    X                   Program attributes
OEATTR7  DS    X                   Program attributes
OEAC     DS    X                   APF authorization code
OESPARE  DS    X                   Spare
OENMLN   DS    H                   Length of member name
OENAME   DS    0C                  Member name
*        DS    H                   Length of entire internal entry

         PRINT NOGEN

         IGWDES

         IGWSMDE

         PRINT GEN
.PDSEHFS ANOP
